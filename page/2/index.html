<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon.png">
  <link rel="mask-icon" href="/images/icon.png" color="#222">
  <meta name="google-site-verification" content="DMyRve2tDXDJqmJpSS4BaBWT1R0ZCH9n_EsCnROTiM0">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css" integrity="sha256-xejo6yLi6vGtAjcMIsY8BHdKsLg7QynVlFMzdQgUuy8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"milanochuang.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.12.3","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜尋...","empty":"我們無法找到任何有關 ${query} 的搜索結果","hits_time":"${hits} 找到 ${time} 個結果","hits":"找到 ${hits} 個結果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="目前就讀於政大語言所，研究興趣為計算語言學">
<meta property="og:type" content="website">
<meta property="og:title" content="米蘭牛角尖">
<meta property="og:url" content="https://milanochuang.github.io/page/2/index.html">
<meta property="og:site_name" content="米蘭牛角尖">
<meta property="og:description" content="目前就讀於政大語言所，研究興趣為計算語言學">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="Hao Yun Chuang (Milan)">
<meta property="article:tag" content="自然語言處理, 計算語言學, 機器學習, 人工智慧, 電影">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://milanochuang.github.io/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-TW","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>米蘭牛角尖</title>
  






  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切換導航欄" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">米蘭牛角尖</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">計算語言學的學習紀錄，偶爾可能會出現野生的電影評論？</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首頁</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>關於</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>標籤</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分類</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>所有文章</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目錄
        </li>
        <li class="sidebar-nav-overview">
          本站概要
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hao Yun Chuang (Milan)"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Hao Yun Chuang (Milan)</p>
  <div class="site-description" itemprop="description">目前就讀於政大語言所，研究興趣為計算語言學<br/></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">文章</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分類</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">標籤</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/milanochuang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;milanochuang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:milanochuang@gmail.com" title="E-Mail → mailto:milanochuang@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/milanochuang" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;milanochuang" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.facebook.com/milanochuang" title="FB Page → https:&#x2F;&#x2F;www.facebook.com&#x2F;milanochuang" rel="noopener" target="_blank"><i class="fab fa-facebook fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/milanochuang" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;milanochuang" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i></a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="回到頂端">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/milanochuang" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://milanochuang.github.io/2023/01/08/NLP%E3%80%91Day-21-%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8-Python-%E6%90%AD%E5%BB%BA-Tensorflow-%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%AD%B8%E7%BF%92%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Hao Yun Chuang (Milan)">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="米蘭牛角尖">
      <meta itemprop="description" content="目前就讀於政大語言所，研究興趣為計算語言學<br/>">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 米蘭牛角尖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/01/08/NLP%E3%80%91Day-21-%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8-Python-%E6%90%AD%E5%BB%BA-Tensorflow-%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%AD%B8%E7%BF%92%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">NLP】Day 21: 手把手教你如何利用 Python 搭建 Tensorflow 的深度學習模型 </a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2023-01-08 19:56:00 / 修改時間：19:56:50" itemprop="dateCreated datePublished" datetime="2023-01-08T19:56:00+08:00">2023-01-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/natural-language-processing/" itemprop="url" rel="index"><span itemprop="name">自然語言處理</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>啊！好久沒有實作了，不曉得各位還記不記得怎麼寫 Python 呢？今天的這篇文章將主要以實作為主，簡單地介紹如何搭建出我們在過去幾天的旅程中，學到的那些形形色色的深度學習模型：LSTM、GRU，以及兩者的雙向版本，也就是BiLSTM、以及BiGRU。不過，你可能已經發現，咦？那單純的 RNN 呢？事實上，在自然語言處理的實務中，由於先前提過的那些缺失，如記性不好等問題，已經很少人使用單純的 RNN 來完成任務了。欸！別人都是一篇一個神經網路，我直接一篇全部寫完，超值吧！還不趕快再點一下我其他文章！</p>
<p>不過在開始弄髒你的手實際上工之前，我們得先了解今天要用的工具有哪些。</p>
<h2 id="今天要使用的工具箱"><a href="#今天要使用的工具箱" class="headerlink" title="今天要使用的工具箱"></a>今天要使用的工具箱</h2><p>對於一些可能從未寫過程式的朋友，可能會有一些疑慮，擔心說「我們該不會要從零開始搭神經網路吧？先前介紹過的那些輸出層、輸入層、隱藏層殺毀的，我們都要從頭開始做起嗎？別吧？」接著擺出了 No No No 的手勢。</p>
<p><img src="https://i.imgur.com/x3YOaph.jpg"></p>
<p>事實上，像這種這麼常用的深度學習工具，不可能沒有前人寫過。所謂前人種樹，後人乘涼，在過去就已經有程式大神代替我們將這些深度學習以及神經網路整理成 API 了。什麼？你說什麼是API？沒事，你只需要理解因為某邪惡大神的建樹，我們只需要簡單地引入（<code>import</code>）工具箱後，這些神經網路就可以隨取隨用了。我想，最多只需要調參數、以及疊各種隱藏層吧？而我今天就會一步一步地仔細帶領你撰寫搭建模型的程式，並逐句介紹這些程式語言在做什麼。至於是哪個大神如此邪惡，擁有幾乎全世界所有網頁的資料，又有極大量的運算資源？其實也沒有別人了，就是：</p>
<p><img src="https://i.redd.it/1qskl89lxzs31.png"></p>
<h3 id="Tensorflow"><a href="#Tensorflow" class="headerlink" title="Tensorflow"></a>Tensorflow</h3><p>Tensorflow 是一個開源的深度學習程式庫，並利用機器學習來完成各種人工智慧的下游任務，例如：圖像辨識，還有我們的重點，自然語言處理。你現在所用的幾乎所有 Google 的服務，舉凡如 Google 搜尋、Google 翻譯（乙定要有的吧！）、GOogle 語音辨識、Google 地圖、Google 相片，都是來自於利用 Tensorflow 的深度學習框架所打造而成的。換句話說，我們其實就是站在 Google 打造好的立足點來解決自然語言處理的應用。</p>
<h2 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h2><p>首先，在程式檔的頂端，我們得先引用搭建神經網路所需要的工具箱，也就是 Tensorflow。今天，我們會直接使用 tensorflow 內建的 imdb 資料集。<del>資料科學的前輩對imdb資料一定又愛又恨吧！</del></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.datasets <span class="keyword">import</span> imdb <span class="comment"># 引入資料集</span></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> Sequential <span class="comment"># 引入序列模型，記得我們在先前提到的 sequence model嗎？</span></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.layers <span class="keyword">import</span> Dense <span class="comment"># 一層全連接的神經網路</span></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.layers <span class="keyword">import</span> LSTM <span class="comment"># 長短期記憶（Long Short-term memory）</span></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.layers <span class="keyword">import</span> Embedding <span class="comment"># 使模型理解語意的 Embedding</span></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.preprocessing <span class="keyword">import</span> sequence </span><br><span class="line"><span class="comment"># 在前處理會需要用到，將長短不一的資料補齊或截斷成相同長度（記得我們先前所說神經網路的長度可以彈性調整嗎？就是透過這裡將序列轉換成相同長度）</span></span><br><span class="line">tf.random.set_seed(<span class="number">7</span>)  <span class="comment"># 設定隨機種子</span></span><br></pre></td></tr></table></figure>
<p>再來得將資料先處理好，我們在這邊先將資料處理好之後，後續在搭建無論是 GRU，甚至是BiLSTM、BiGRU，都會直接用這裡的資料，就不會再重複這裡的動作啦！</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 設定資料中字頻前五千的字</span></span><br><span class="line">top_words = <span class="number">5000</span> </span><br><span class="line"><span class="comment"># 取得資料後，分成訓練資料集以及測試資料集</span></span><br><span class="line">(X_train, y_train), (X_test, y_test) = imdb.load_data(num_words=top_words) </span><br><span class="line"><span class="comment"># 在這裡就是要截斷或補齊輸入模型的句子，以保持所有句子長度相同。</span></span><br><span class="line">max_review_length = <span class="number">500</span></span><br><span class="line">X_train = sequence.pad_sequences(X_train, maxlen=max_review_length)</span><br><span class="line">X_test = sequence.pad_sequences(X_test, maxlen=max_review_length)</span><br></pre></td></tr></table></figure>
<p>接著要先搭建模型，搭建完模型之後才會開始訓練。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">embedding_vector_length = <span class="number">32</span></span><br><span class="line"><span class="comment"># 首先設定模型為序列模型</span></span><br><span class="line">lstm_model = Sequential()</span><br><span class="line"><span class="comment"># 將已經訓練好的 Embedding 加入神經網路模型中</span></span><br><span class="line">lstm_model.add(Embedding(top_words, embedding_vector_length, input_length=max_review_length))</span><br><span class="line"><span class="comment"># LSTM函數中的值則是代表你要在模型中放入多少 LSTM 的神經元（有門閥的那個）</span></span><br><span class="line">lstm_model.add(LSTM(<span class="number">100</span>))</span><br><span class="line"><span class="comment"># 全連接的神經網路隱藏層，可以選擇想要的激勵函數</span></span><br><span class="line">lstm_model.add(Dense(<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>))</span><br><span class="line"><span class="comment"># 這裡的compile是在將模型組合起來。</span></span><br><span class="line">lstm_model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>, optimizer=<span class="string">&#x27;adam&#x27;</span>, metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line"><span class="comment"># 可以一起來看看模型長怎樣</span></span><br><span class="line"><span class="built_in">print</span>(lstm_model.summary())</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Model: &quot;sequential&quot;</span><br><span class="line">_________________________________________________________________</span><br><span class="line"> Layer (type)                Output Shape              Param #   </span><br><span class="line">=================================================================</span><br><span class="line"> embedding (Embedding)       (None, 500, 32)           160000    </span><br><span class="line">                                                                 </span><br><span class="line"> lstm (LSTM)                 (None, 100)               53200     </span><br><span class="line">                                                                 </span><br><span class="line"> dense (Dense)               (None, 1)                 101       </span><br><span class="line">                                                                 </span><br><span class="line">=================================================================</span><br><span class="line">Total params: 213,301</span><br><span class="line">Trainable params: 213,301</span><br><span class="line">Non-trainable params: 0</span><br><span class="line">_________________________________________________________________</span><br><span class="line">None</span><br></pre></td></tr></table></figure>
<p>我們從<code>params</code>中可以看到模型總共有多少個參數。另外，在 LSTM 中的參數決定的是神經元數量，沒有一定的固定數字，但是有個模式可循。首先，RNN 的寬度代表特徵的多寡，由輸入以及篩選器的數量決定；深度代表的則是特徵的豐富度，由神經網路層數及步驟數決定的。若不需要從原資料產出大量特徵，那麼一般來說寬度會減少。若資料相對單純，那麼深度則需要調整的淺一點，這麼做可以節省訓練時間及資源。(<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/59072728/what-is-the-rule-to-know-how-many-lstm-cells-and-how-many-units-in-each-lstm-cel">source</a>)</p>
<p>確認沒問題之後，就可以開始訓練模型了！這裡可能會需要跑比較久時間，像我試跑就跑了十分多鐘，所以才說深度學習模型的一個缺點就是速度比較慢一點。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model.fit(X_train, y_train, epochs=<span class="number">3</span>, batch_size=<span class="number">64</span>) <span class="comment"># 訓練模型</span></span><br><span class="line">scores = model.evaluate(X_test, y_test, verbose=<span class="number">0</span>) <span class="comment"># 測試模型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Accuracy: %.2f%%&quot;</span> % (scores[<span class="number">1</span>]*<span class="number">100</span>)) </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Epoch 1/3</span><br><span class="line">391/391 [==============================] - 207s 525ms/step - loss: 0.4316 - accuracy: 0.7884</span><br><span class="line">Epoch 2/3</span><br><span class="line">391/391 [==============================] - 205s 525ms/step - loss: 0.2653 - accuracy: 0.8937</span><br><span class="line">Epoch 3/3</span><br><span class="line">391/391 [==============================] - 204s 522ms/step - loss: 0.2377 - accuracy: 0.9065</span><br><span class="line">Accuracy: 86.72%</span><br></pre></td></tr></table></figure>
<h2 id="BiLSTM"><a href="#BiLSTM" class="headerlink" title="BiLSTM"></a>BiLSTM</h2><p>其實雙向的 BiLSTM 也是大同小異，我們只需要關注模型的搭建上就可以了。資料一樣沿用在上面所整理好的訓練以及測試資料集。別忘了要先引進雙向的套件，至於其他的套件，在前面就已經引進過，就不需要再引進了。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.layers <span class="keyword">import</span> Bidirectional</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bilstm_model = Sequential()</span><br><span class="line">bilstm_model.add(Embedding(top_words, embedding_vetcor_length, input_length=max_review_length))</span><br><span class="line">bilstm_model.add(Bidirectional(LSTM(<span class="number">100</span>, dropout=<span class="number">0.2</span>, recurrent_dropout=<span class="number">0.2</span>)))</span><br><span class="line">bilstm_model.add(Dense(<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>))</span><br><span class="line">bilstm_model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>, optimizer=<span class="string">&#x27;adam&#x27;</span>, metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(bilstm_model.summary()) <span class="comment"># 同樣先來看模型參數</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Model: &quot;sequential_1&quot;</span><br><span class="line">_________________________________________________________________</span><br><span class="line"> Layer (type)                Output Shape              Param #   </span><br><span class="line">=================================================================</span><br><span class="line"> embedding_1 (Embedding)     (None, 500, 32)           160000    </span><br><span class="line">                                                                 </span><br><span class="line"> bidirectional (Bidirectiona  (None, 200)              106400    </span><br><span class="line"> l)                                                              </span><br><span class="line">                                                                 </span><br><span class="line"> dense_1 (Dense)             (None, 1)                 201       </span><br><span class="line">                                                                 </span><br><span class="line">=================================================================</span><br><span class="line">Total params: 266,601</span><br><span class="line">Trainable params: 266,601</span><br><span class="line">Non-trainable params: 0</span><br><span class="line">_________________________________________________________________</span><br><span class="line">None</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bilstm_model.fit(X_train, y_train, epochs=<span class="number">3</span>, batch_size=<span class="number">64</span>)</span><br><span class="line">scores = bilstm_model.evaluate(X_test, y_test, verbose=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Accuracy: %.2f%%&quot;</span> % (scores[<span class="number">1</span>]*<span class="number">100</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Epoch 1/3</span><br><span class="line">391/391 [==============================] - 805s 2s/step - loss: 0.4870 - accuracy: 0.7579</span><br><span class="line">Epoch 2/3</span><br><span class="line">391/391 [==============================] - 803s 2s/step - loss: 0.3148 - accuracy: 0.8726</span><br><span class="line">Epoch 3/3</span><br><span class="line">391/391 [==============================] - 799s 2s/step - loss: 0.2637 - accuracy: 0.8944</span><br><span class="line">Accuracy: 87.89%</span><br></pre></td></tr></table></figure>
<p>BiLSTM 因為參數更多，所以訓練時間又很明顯地變更久了。我在這裡花了快20多分鐘在訓練模型。</p>
<h2 id="GRU"><a href="#GRU" class="headerlink" title="GRU"></a>GRU</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gru_model = Sequential()</span><br><span class="line">gru_model.add(Embedding(top_words, embedding_vector_length, input_length=max_review_length))</span><br><span class="line">gru_model.add(GRU(<span class="number">32</span>))</span><br><span class="line">gru_model.add(Dense(<span class="number">10</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">gru_model.add(Dense(<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>))</span><br><span class="line">gru_model.<span class="built_in">compile</span>(loss=<span class="string">&quot;binary_crossentropy&quot;</span>, optimizer=<span class="string">&#x27;adam&#x27;</span>,metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(gru_model.summary())</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Model: &quot;sequential_2&quot;</span><br><span class="line">_________________________________________________________________</span><br><span class="line"> Layer (type)                Output Shape              Param #   </span><br><span class="line">=================================================================</span><br><span class="line"> embedding_2 (Embedding)     (None, 500, 32)           160000    </span><br><span class="line">                                                                 </span><br><span class="line"> gru (GRU)                   (None, 32)                6336      </span><br><span class="line">                                                                 </span><br><span class="line"> dense_2 (Dense)             (None, 10)                330       </span><br><span class="line">                                                                 </span><br><span class="line"> dense_3 (Dense)             (None, 1)                 11        </span><br><span class="line">                                                                 </span><br><span class="line">=================================================================</span><br><span class="line">Total params: 166,677</span><br><span class="line">Trainable params: 166,677</span><br><span class="line">Non-trainable params: 0</span><br><span class="line">_________________________________________________________________</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gru_model.fit(X_train, y_train, epochs=<span class="number">3</span>, batch_size=<span class="number">64</span>)</span><br><span class="line">scores = gru_model.evaluate(X_test, y_test, verbose=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Accuracy: %.2f%%&quot;</span> % (scores[<span class="number">1</span>]*<span class="number">100</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Epoch 1/3</span><br><span class="line">391/391 [==============================] - 89s 222ms/step - loss: 0.4658 - accuracy: 0.7620</span><br><span class="line">Epoch 2/3</span><br><span class="line">391/391 [==============================] - 88s 226ms/step - loss: 0.2631 - accuracy: 0.8943</span><br><span class="line">Epoch 3/3</span><br><span class="line">391/391 [==============================] - 88s 224ms/step - loss: 0.2215 - accuracy: 0.9149</span><br><span class="line">Accuracy: 87.74%</span><br></pre></td></tr></table></figure>
<p>GRU 模型當初有說，其實設計架構上與 LSTM 差不了多少，但是由於 GRU 的參數相對比較少的緣故，所以運算時間還有資源都比原本的 LSTM 還要少。在準確度皆為接近 90% 的前提下，我在前面訓練 LSTM 的時間為十一分鐘左右，而這裡 GRU 我卻只需要五分多鐘就結束訓練了。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bigru_model = Sequential()</span><br><span class="line">bigru_model.add(Embedding(top_words, embedding_vector_length, input_length=max_review_length))</span><br><span class="line">bigru_model.add(Bidirectional(GRU(<span class="number">32</span>)))</span><br><span class="line">bigru_model.add(Dense(<span class="number">10</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">bigru_model.add(Dense(<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>))</span><br><span class="line">bigru_model.<span class="built_in">compile</span>(loss=<span class="string">&quot;binary_crossentropy&quot;</span>, optimizer=<span class="string">&#x27;adam&#x27;</span>,metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line">bigru_model.summary()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Model: &quot;sequential_3&quot;</span><br><span class="line">_________________________________________________________________</span><br><span class="line"> Layer (type)                Output Shape              Param #   </span><br><span class="line">=================================================================</span><br><span class="line"> embedding_3 (Embedding)     (None, 500, 32)           160000    </span><br><span class="line">                                                                 </span><br><span class="line"> bidirectional_1 (Bidirectio  (None, 64)               12672     </span><br><span class="line"> nal)                                                            </span><br><span class="line">                                                                 </span><br><span class="line"> dense_4 (Dense)             (None, 10)                650       </span><br><span class="line">                                                                 </span><br><span class="line"> dense_5 (Dense)             (None, 1)                 11        </span><br><span class="line">                                                                 </span><br><span class="line">=================================================================</span><br><span class="line">Total params: 173,333</span><br><span class="line">Trainable params: 173,333</span><br><span class="line">Non-trainable params: 0</span><br><span class="line">_________________________________________________________________</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bigru_model.fit(X_train, y_train, epochs=<span class="number">3</span>, batch_size=<span class="number">64</span>)</span><br><span class="line">scores = bigru_model.evaluate(X_test, y_test, verbose=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Accuracy: %.2f%%&quot;</span> % (scores[<span class="number">1</span>]*<span class="number">100</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Epoch <span class="number">1</span>/<span class="number">3</span></span><br><span class="line"><span class="number">391</span>/<span class="number">391</span> [==============================] - 166s 414ms/step - loss: <span class="number">0.4397</span> - accuracy: <span class="number">0.7790</span></span><br><span class="line">Epoch <span class="number">2</span>/<span class="number">3</span></span><br><span class="line"><span class="number">391</span>/<span class="number">391</span> [==============================] - 160s 408ms/step - loss: <span class="number">0.2599</span> - accuracy: <span class="number">0.8975</span></span><br><span class="line">Epoch <span class="number">3</span>/<span class="number">3</span></span><br><span class="line"><span class="number">391</span>/<span class="number">391</span> [==============================] - 159s 407ms/step - loss: <span class="number">0.2170</span> - accuracy: <span class="number">0.9153</span></span><br><span class="line">Accuracy: <span class="number">87.74</span>%</span><br></pre></td></tr></table></figure>
<p>BiGRU 的模型訓練時間跟 BiLSTM 相比就更明顯了，BiLSTM 我當初花了 40 分鐘左右才訓練完成，反觀 BiGRU，只需要 9 分鐘左右就結束了，模型表現卻也都差不多。</p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>我們最後來看一下結果，可以發現四種表現都沒有差距太大，但訓練時間就有明顯的差異，也就是 GRU 的時間還要少於 LSTM；另外，雙向的神經網路模型表現也比單向還要好一些。</p>
<table>
<thead>
<tr>
<th></th>
<th>LSTM</th>
<th>BiLSTM</th>
<th>GRU</th>
<th>BiGRU</th>
</tr>
</thead>
<tbody><tr>
<td>準確度 <strong>(%)</strong></td>
<td>86.72</td>
<td>87.89</td>
<td>87.74</td>
<td>87.74</td>
</tr>
<tr>
<td>時間 <strong>(min)</strong></td>
<td>11</td>
<td>19</td>
<td>5.5</td>
<td>9</td>
</tr>
</tbody></table>
<p>這也印證了在先前 <a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/articles/10302765">【NLP】Day 17: 每天成為更好的自己！神經網路也是！深度學習模型 GRU</a> 的文章中所說，參數的多寡會大大影響著運算時間以及資源。好，神經網路的實作就到這邊，是不是比想像中的還要簡單很多呢？明天開始就要進入 BERT 了喔！</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://milanochuang.github.io/2023/01/08/%E3%80%90NLP%E3%80%91Day-20-%E6%94%BE%E9%BB%9E%E6%B3%A8%E6%84%8F%E5%8A%9B%E5%9C%A8%E5%A4%9A%E9%A0%AD%E4%B8%8A%EF%BC%88NLP%E4%B9%9F%E6%9C%89%E5%A4%9A%E9%A0%AD%E5%95%8A%EF%BC%81%EF%BC%89%EF%BC%9ATransformer%EF%BC%88%E4%B8%8B%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Hao Yun Chuang (Milan)">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="米蘭牛角尖">
      <meta itemprop="description" content="目前就讀於政大語言所，研究興趣為計算語言學<br/>">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 米蘭牛角尖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/01/08/%E3%80%90NLP%E3%80%91Day-20-%E6%94%BE%E9%BB%9E%E6%B3%A8%E6%84%8F%E5%8A%9B%E5%9C%A8%E5%A4%9A%E9%A0%AD%E4%B8%8A%EF%BC%88NLP%E4%B9%9F%E6%9C%89%E5%A4%9A%E9%A0%AD%E5%95%8A%EF%BC%81%EF%BC%89%EF%BC%9ATransformer%EF%BC%88%E4%B8%8B%EF%BC%89/" class="post-title-link" itemprop="url">【NLP】Day 20: 放點注意力在多頭上（NLP也有多頭啊！）：Transformer（下）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2023-01-08 19:55:13 / 修改時間：19:55:30" itemprop="dateCreated datePublished" datetime="2023-01-08T19:55:13+08:00">2023-01-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>空頭不死，多頭不止；多頭不死，空頭不止<br><strong>不詳</strong></p>
</blockquote>
<p>在股票市場中，人人著稱的一句話：「空頭不死，多頭不止；多頭不死，空頭不止。」意思是，如果股價在下降的趨勢時中，如果想一直有抄底，期望做反彈的人不斷進場的話，那麼市場就會不斷下跌。我想我在這裡可以再多加一句：</p>
<blockquote>
<p>單頭一有，強到流油；注意多頭，更上層樓！<br><strong>By me</strong></p>
</blockquote>
<p>只是差別是，一個在講的是股市走向及股民心理，另一個則是在講 <a target="_blank" rel="noopener" href="https://arxiv.org/abs/1706.03762">Attention Is All You Need</a> 論文的 Transformer 模型，以及在其中所運用的自注意力機制（Self-attention Mechanism）。昨天的文章中，我們已經簡單地了解何謂自注意力機制。在同一篇文章中，作者又針對這個自注意力機制再次進行了改良 <del>完全不給其他人優化的機會喔</del>，也就是將原本提出的單一自注意力機制，在模型中改良成<strong>多頭自注意力機制（Multi-head Self-attention Mechanism）</strong>。今天，就讓我們一起來看看 Multi-head Self-Attention Mechanism 跟原本的有什麼不一樣呢？接著，再把剩下的 Encoder 以及 Decoder 走完吧！</p>
<h3 id="Multi-head-Self-attention-Mechanism"><a href="#Multi-head-Self-attention-Mechanism" class="headerlink" title="Multi-head Self-attention Mechanism"></a>Multi-head Self-attention Mechanism</h3><p>若你還記得的話，在昨天的文章，<a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/articles/10303885">【NLP】Day 19: 注意！謝謝你的注意！Transformer （上）</a>之中，曾經提到 Transformer 會將每一個字的向量（也就是Word-embedding）乘上一個權重 <img src="https://chart.googleapis.com/chart?cht=tx&chl=W" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=W"> 之後，會得到三個不同的向量，分別是 <img src="https://chart.googleapis.com/chart?cht=tx&chl=Q" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=Q">、<img src="https://chart.googleapis.com/chart?cht=tx&chl=K" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=K"> 以及 <img src="https://chart.googleapis.com/chart?cht=tx&chl=V" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=V"> ，也就是 queue vector、key vector，以及value vector。那 Multi-head Self-attention Mechanism 其實就是<strong>不同的字要乘上不同的權重</strong> <img src="https://chart.googleapis.com/chart?cht=tx&chl=W" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=W"> ，也就是說，不同的字會有不同的<img src="https://chart.googleapis.com/chart?cht=tx&chl=Q" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=Q">、<img src="https://chart.googleapis.com/chart?cht=tx&chl=K" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=K"> 以及 <img src="https://chart.googleapis.com/chart?cht=tx&chl=V" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=V"> 。我們可以先看看下圖：</p>
<p><img src="https://jalammar.github.io/images/t/transformer_attention_heads_qkv.png"></p>
<p>在這邊再強調一次，這邊的 <img src="https://chart.googleapis.com/chart?cht=tx&chl=Q" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=Q">、<img src="https://chart.googleapis.com/chart?cht=tx&chl=K" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=K"> 以及 <img src="https://chart.googleapis.com/chart?cht=tx&chl=V" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=V"> 三個向量，是 <img src="https://chart.googleapis.com/chart?cht=tx&chl=X" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=X"> 分別與 <img src="https://chart.googleapis.com/chart?cht=tx&chl=W_%7Bi%5EQ%7D" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=W_%7Bi%5EQ%7D"> 、 <img src="https://chart.googleapis.com/chart?cht=tx&chl=W_%7Bi%5Ek%7D" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=W_%7Bi%5Ek%7D"><br>以及 <img src="https://chart.googleapis.com/chart?cht=tx&chl=W_%7Bi%5Ev%7D" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=W_%7Bi%5Ev%7D"> 內積所得的結果。有幾個維度，就有幾個 Head；同理，若訓練資料的 Word Embedding 總共有 8 個維度，那麼就會有 8 個不同的 Head。最後我們就會得到 8 個 <img src="https://chart.googleapis.com/chart?cht=tx&chl=Z" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=Z"> 的<strong>矩陣</strong>。 但是問題在於，接下來要將資料餵入的模型事前饋神經網路（Feed-forward Neural Network），吃的是每個 <strong>字</strong> 一個 <strong>向量</strong>。這時候就是要再乘上 <img src="https://chart.googleapis.com/chart?cht=tx&chl=W_o" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=W_o"> 將這一大串的矩陣再轉回成一個字一個向量（因為在圖中是兩個字，所以會變成是兩個矩陣）。</p>
<p><img src="https://jalammar.github.io/images/t/transformer_attention_heads_weight_matrix_o.png"></p>
<p>那我們綜觀下來，self-attention 的機制就如下圖運作。</p>
<p><img src="https://jalammar.github.io/images/t/transformer_multi-headed_self-attention-recap.png"></p>
<h4 id="Multi-head-Self-attention-Mechanism-哪裡比較好？"><a href="#Multi-head-Self-attention-Mechanism-哪裡比較好？" class="headerlink" title="Multi-head Self-attention Mechanism 哪裡比較好？"></a>Multi-head Self-attention Mechanism 哪裡比較好？</h4><ol>
<li><p>Multi-head 的機制更可以讓模型專注在一句話中的不同字上。雖然說在 Single-head 的機制底下，對其中一個字來說，一句話的其他字在這個字的編碼中會含有一點點的權重，但在某些情況下，還是有可能會特別側重在某個字上。但 Multi-head 就可以淡化這個問題。</p>
</li>
<li><p>若你還記得的話，Multi-head 的機制針對一句話中的不同字，各自會有不同的 <a target="_blank" rel="noopener" href="https://chart.googleapis.com/chart?cht=tx&chl=W_%7Bi%5EQ%7D">https://chart.googleapis.com/chart?cht=tx&chl=W_%7Bi%5EQ%7D</a> 、 <img src="https://chart.googleapis.com/chart?cht=tx&chl=W_%7Bi%5Ek%7D" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=W_%7Bi%5Ek%7D"><br>以及 <img src="https://chart.googleapis.com/chart?cht=tx&chl=W_%7Bi%5Ev%7D" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=W_%7Bi%5Ev%7D"> 權重，這麼一來也可以提供模型的語意空間更高的彈性。（這是我的理解，若有錯誤還請前輩不吝指正。）</p>
</li>
</ol>
<h3 id="位置編碼（Positional-Encoding）"><a href="#位置編碼（Positional-Encoding）" class="headerlink" title="位置編碼（Positional Encoding）"></a>位置編碼（Positional Encoding）</h3><p>要知道字在文中的不同位置對於語意理解上也扮演著很重要的角色，所以我們必須在模型中加入位置的資訊，也就是所謂的位置編碼（Positional Encoding），這可以幫助模型理解<strong>一個字在資料中的位置</strong>，以及<strong>與其他字的距離</strong>。</p>
<p><img src="https://jalammar.github.io/images/t/transformer_positional_encoding_vectors.png"></p>
<p>實際上會長這樣：</p>
<p><img src="https://jalammar.github.io/images/t/transformer_positional_encoding_example.png"></p>
<h3 id="殘差標準化（Residual-amp-Normalization）"><a href="#殘差標準化（Residual-amp-Normalization）" class="headerlink" title="殘差標準化（Residual &amp; Normalization）"></a>殘差標準化（Residual &amp; Normalization）</h3><p>因為在運算資料的過程中會產生殘差，所以也要經過標準化。這層標準化層，在編碼器以及解碼器中都會加入。</p>
<p><img src="https://jalammar.github.io/images/t/transformer_resideual_layer_norm_2.png"></p>
<p><img src="https://jalammar.github.io/images/t/transformer_resideual_layer_norm_3.png"></p>
<h2 id="解碼器（decoder）"><a href="#解碼器（decoder）" class="headerlink" title="解碼器（decoder）"></a>解碼器（decoder）</h2><p>在編碼器，我們將文本序列作為輸入資料，在最後一個編碼器會得到兩個 attention vector，分別是 <img src="https://chart.googleapis.com/chart?cht=tx&chl=K" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=K"> 以及 <img src="https://chart.googleapis.com/chart?cht=tx&chl=V" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=V"> 。 這兩個向量可以幫助在每個解碼器中的 encoder-decoder attention 了解輸入序列中這些字的資訊。</p>
<p><img src="https://jalammar.github.io/images/t/transformer_decoding_1.gif"></p>
<p>在接下來的解碼中，除了前面兩個 attention vector 的幫助，同樣也會在解碼器端加入前文的 word embedding 以及 positional encoding，同樣也是為了要幫助模型了解語意距離、位置資訊等等，以利模型進行解碼。</p>
<p><img src="https://jalammar.github.io/images/t/transformer_decoding_2.gif"></p>
<h2 id="最終輸出層（Final-Linear-and-Softmax-Layer）"><a href="#最終輸出層（Final-Linear-and-Softmax-Layer）" class="headerlink" title="最終輸出層（Final Linear and Softmax Layer）"></a>最終輸出層（Final Linear and Softmax Layer）</h2><p>最後一哩路啦！在解碼器的尾端，我們最後得到的輸出是由浮點數所組成的向量，但我們需要文字輸出的話，該怎麼辦？所以最後就會需要<strong>線性層（Linear Layer）</strong>以及<strong>激勵函數層（Softmax Layer）</strong>來幫助模型將這些數值資料轉回文字。</p>
<p>線性層是一個完全連接的神經網路。簡單的說，線性層可以將解碼器的輸出向量<strong>轉化成另外一種可以「儲存字彙」的向量</strong>，文中稱為 Logits vector。假如說今天模型在訓練資料中學習了 10000 個字，那麼在這個叫 Logits vector 的向量中就會有 10000 個元素，這些元素分別又代表了不同分數（score），這些分數都可以對應回去每一個字。</p>
<p>Softmax 則會在這10000個元素中的每一個元素各分配一個概率，讓模型用這個概率決定該以哪個字作為最後的輸出。</p>
<p><img src="https://jalammar.github.io/images/t/transformer_decoder_output_softmax.png"></p>
<h2 id="問題與討論"><a href="#問題與討論" class="headerlink" title="問題與討論"></a>問題與討論</h2><ol>
<li><strong>解釋力偏低</strong>：由於 Transformer 算是深度學習模型的其中一種，所以通常解釋力都比較低。我們沒有辦法跟人解釋模型是如何運算得出某個特定的輸出結果。其實無論是 Transformer 還是前面介紹的 RNN，還有接下來要介紹的 BERT，都有一樣的問題。</li>
<li><strong>難以控制自注意力機制的運作</strong>：因為自注意力的運算機制，導致模型有漏字的可能。舉例來說，我們透過Google翻譯 <code>one one one one two two one one twenty two</code> 可以得到 <code>一一一二二一一二二</code> ，但我們都知道少了一個<code>一</code>。 <a target="_blank" rel="noopener" href="https://www.quora.com/Which-are-the-weaknesses-of-transformers-in-deep-learning">Source</a><br><img src="https://i.imgur.com/uxuaDTX.png"></li>
<li><strong>訓練時間長</strong>：我們用了好多attention head、好多的參數、好多的運算，那訓練一個模型的時間就會拉的特別長。一天兩天已算少，一週兩週剛剛好。</li>
</ol>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>好！既然我們已經了解了什麼是 Transformer，就代表我們已經做好萬全準備進入現在最強最常用的語言模型 BERT 啦！我們明天見！</p>
<p>參考資料：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://jalammar.github.io/illustrated-transformer/">The Illustrated Transformer</a></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/ching-i/transformer-attention-is-all-you-need-c7967f38af14">謦伊的閱讀筆記</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://milanochuang.github.io/2023/01/08/%E3%80%90NLP%E3%80%91Day-19-%E6%B3%A8%E6%84%8F%EF%BC%81%E8%AC%9D%E8%AC%9D%E4%BD%A0%E7%9A%84%E6%B3%A8%E6%84%8F%EF%BC%81Transformer-%EF%BC%88%E4%B8%8A%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Hao Yun Chuang (Milan)">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="米蘭牛角尖">
      <meta itemprop="description" content="目前就讀於政大語言所，研究興趣為計算語言學<br/>">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 米蘭牛角尖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/01/08/%E3%80%90NLP%E3%80%91Day-19-%E6%B3%A8%E6%84%8F%EF%BC%81%E8%AC%9D%E8%AC%9D%E4%BD%A0%E7%9A%84%E6%B3%A8%E6%84%8F%EF%BC%81Transformer-%EF%BC%88%E4%B8%8A%EF%BC%89/" class="post-title-link" itemprop="url">【NLP】Day 19: 注意！謝謝你的注意！Transformer （上）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2023-01-08 19:54:20 / 修改時間：19:54:37" itemprop="dateCreated datePublished" datetime="2023-01-08T19:54:20+08:00">2023-01-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>如果我能看得更遠，那是因為站在巨人的肩膀上。<br><strong>牛頓</strong></p>
</blockquote>
<p>經過了前幾天的旅程，相信大家對於運用在自然語言處理的神經網路，應該已經有了一定程度的認識。神經網路是深度學習的起點，我們一路從機器學習一直到現在的深度學習，其實都依循著一定的脈絡在往前走。不知道大家是否還記得我們在旅程一開始的時候曾經說過，為了要讓機器學習模型理解文字，首要工作是要將文字轉換成數字，因此發展出了許多如詞頻、TF-IDF等<strong>以詞為模型理解語言的最小單位</strong>的方式，接著以詞頻為基礎，將語言理解成<strong>具有統計概念的分布模型</strong>，因此這樣的模型被稱為<strong>語言模型</strong>，接著將這些轉成數值的文字資料放進傳統機器學習模型。後來，人工智慧學家發現，比起讓模型從詞彙的角度出發，讓模型可以理解文字、句子、甚至是文章上下文之間的連續關係，其實應用上可以更為廣泛。</p>
<p>就跟我們人有著不同專長一樣，不同的模型也擅長處理不同的資料。當模型處理具有<strong>序列關係</strong>的資料時，這種<strong>sequence model</strong>就是最好的選擇，也就是說，我們前幾天所說到的模型，RNN、LSTM、GRU等，都是sequence model的一種。</p>
<p>今天要介紹的，也是一種sequence model，稱為Transformer。今天這篇文將會有很大一部分是來自於 <a target="_blank" rel="noopener" href="https://jalammar.github.io/illustrated-transformer/">The Illustrated Transformer</a>這篇文章，若各位想拜讀原文，可以毫不猶豫地點進去這篇文章喔！</p>
<h2 id="自然語言處理的變形金剛：Transformer"><a href="#自然語言處理的變形金剛：Transformer" class="headerlink" title="自然語言處理的變形金剛：Transformer"></a>自然語言處理的變形金剛：Transformer</h2><p>如果我們將模型視作一個黑盒子，那首先要先釐清，輸入模型的資料型態會是一個句子，輸出也會是一個句子（畢竟是sequence model，輸入及輸出也會是 “sequence”），而在這個模型內部，是由一長串的編碼器（encoder）跟解碼器（decoder）所組成。我們可以參考以下示意圖：</p>
<p><img src="https://jalammar.github.io/images/t/The_transformer_encoder_decoder_stack.png"></p>
<p>在圖中我們可以看到，輸入及輸出之間是由一串的編碼器和解碼器所組成。雖然在原文中的圖也是用各六個編碼及解碼器，但事實上跟6這個數字一點關係都沒有。 <del>畢竟不是每個人都是諫山創一樣對數字有執著</del></p>
<p>首先我們先來將注意力放在編碼器（Pun intended！），編碼器的構造又是由 <strong>自注意力機制（self-attention mechanism）以及一組前饋神經網路（feed-forward neural network）</strong> 所組成。另外在解碼器中，除了自注意力機制以及前饋神經網路之外，也多了<strong>編解碼注意力機制（encoder-decoder attention）</strong>，前饋神經網路在我的 <a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/articles/10300871">神經網路也會神機錯亂？不，只會精神錯亂…深度學習：前饋神經網路</a> 這篇文章中已經提過，想必大家應該都很清楚了（吧？）（嗎？）所以今天會將主力放在解釋何謂<strong>自注意力機制</strong>。</p>
<p><img src="https://jalammar.github.io/images/t/Transformer_encoder.png"></p>
<h3 id="自注意力機制（self-attention-mechanism）"><a href="#自注意力機制（self-attention-mechanism）" class="headerlink" title="自注意力機制（self-attention mechanism）"></a>自注意力機制（self-attention mechanism）</h3><p>自注意力機制的要點在於，深度學習模型可以判斷句子中某個字與句中其他字的關聯性大小，比如說，句中某個字的指涉對象是同一句中的哪個字。這樣說或許有點抽象，什麼指涉，什麼關聯性的吊書袋幹嘛？其實若用原文的舉例來說的話：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;The animal didn&#x27;t cross the street because it was too tired.&quot;</span></span><br></pre></td></tr></table></figure>
<p>在這句話中，<code>it</code>的指涉對象就是<code>animal</code>，也就是說，整句話之中，<code>it</code>跟<code>animal</code>的關係最接近，所以模型在進行自注意力機制的時候，就會給<code>animal</code>比較高的權重。這個運作方式就像是先前在<a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/articles/10301346">圓圓圈圈圓圓～深度學習：循環神經網路 RNN</a>之中所說，RNN透過隱藏層之間的資料傳遞（也就是RNN的記憶能力）來了解當前處理的字，與先前處理過的字，兩者之間的關係。</p>
<p><img src="https://jalammar.github.io/images/t/transformer_self-attention_visualization.png"></p>
<h4 id="如何計算的呢？"><a href="#如何計算的呢？" class="headerlink" title="如何計算的呢？"></a>如何計算的呢？</h4><ol>
<li><strong>步驟一</strong>：從編碼器輸入層中（在這裡則是詞嵌入層）中計算出三個向量，分別為key vector、query vector以及value vector。這三個向量分別乘上權重<img src="https://chart.googleapis.com/chart?cht=tx&chl=W%5EQ" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=W%5EQ">、<img src="https://chart.googleapis.com/chart?cht=tx&chl=W%5EK" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=W%5EK"> 以及 <img src="https://chart.googleapis.com/chart?cht=tx&chl=W%5EV" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=W%5EV"> 之後，就可以得到這個字在句子中的投射（projection），也就是用比較短的向量來代表一個字在一個句子之中的「定位」（我的理解，若有錯請指出）。</li>
</ol>
<p><img src="https://jalammar.github.io/images/t/transformer_self_attention_vectors.png"></p>
<ol start="2">
<li><strong>步驟二</strong>：在這裡要做的是，要計算對<strong>當位置</strong>輸入字詞來說，其他字的「重要程度」。作法則是將計算所得的key vector，與自己還有其他字詞的query vector相乘（也就是內積），即可獲得前述所謂「重要程度」的分數。</li>
</ol>
<p><img src="https://jalammar.github.io/images/t/transformer_self_attention_score.png"></p>
<ol start="3">
<li><strong>步驟三</strong>：再來就是除以8，接著把他丟入softmax激勵函數。之所以除以8的原因只是因為這是64的平方根，也就是key vector維度的平方根，這可以幫助在梯度下降時穩定找到最佳解。我們在這裡最終會獲得<code>[0, 1]</code>之間的數字。</li>
</ol>
<p><img src="https://jalammar.github.io/images/t/self-attention_softmax.png"></p>
<ol start="4">
<li><strong>步驟四</strong>：最後就是相乘再相加。<ul>
<li><strong>相乘</strong>：將Softmax所得的數值，乘以value vector。這裡的作用是，將重要的字保留下來，並將不重要的字過濾掉。（因為不重要的字會乘上一個超小的數值，就可以把他的重要性降低了）。</li>
<li><strong>相加</strong>：將前面計算的數值相加，就可以得到在這個「位置」的自注意層輸出了。</li>
</ul>
</li>
</ol>
<p><img src="https://jalammar.github.io/images/t/self-attention-output.png"></p>
<p>是不是已經腦洞大開了呢！但這還只是single-head attention，在原論文 <a target="_blank" rel="noopener" href="https://arxiv.org/abs/1706.03762">Attention Is All You Need</a>中其實又再針對這個概念進行了改良 <del>套句高中數學老師說的，是想逼死誰？</del> ，加入了multi-head attention，而這可以更準確地判斷句中不同位置的字的相對重要程度，不過我們明天再來詳細介紹是怎麼回事，還有後續的decoder的運作方式；另外，朋友們也可以想想看，為什麼在文中，我只要寫到「位置」，我都會特別加上引號。不過我們在這邊先休息一下，明天進入Transformer 下篇！</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://milanochuang.github.io/2023/01/08/%E3%80%90NLP%E3%80%91Day-18-%E6%B2%92%E6%9C%89%E4%BB%80%E9%BA%BC%E6%98%AF%E4%B8%80%E6%A2%9D%E7%A5%9E%E7%B6%93%E7%B6%B2%E8%B7%AF%E8%A7%A3%E6%B1%BA%E4%B8%8D%E4%BA%86%E7%9A%84%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%89%EF%BC%8C%E5%B0%B1%E5%85%A9%E6%A2%9D%EF%BC%81%E6%B7%B1%E5%BA%A6%E5%AD%B8%E7%BF%92%EF%BC%9ABiLSTM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Hao Yun Chuang (Milan)">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="米蘭牛角尖">
      <meta itemprop="description" content="目前就讀於政大語言所，研究興趣為計算語言學<br/>">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 米蘭牛角尖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/01/08/%E3%80%90NLP%E3%80%91Day-18-%E6%B2%92%E6%9C%89%E4%BB%80%E9%BA%BC%E6%98%AF%E4%B8%80%E6%A2%9D%E7%A5%9E%E7%B6%93%E7%B6%B2%E8%B7%AF%E8%A7%A3%E6%B1%BA%E4%B8%8D%E4%BA%86%E7%9A%84%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%89%EF%BC%8C%E5%B0%B1%E5%85%A9%E6%A2%9D%EF%BC%81%E6%B7%B1%E5%BA%A6%E5%AD%B8%E7%BF%92%EF%BC%9ABiLSTM/" class="post-title-link" itemprop="url">【NLP】Day 18: 沒有什麼是一條神經網路解決不了的，如果有，就兩條！深度學習：BiLSTM </a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2023-01-08 19:52:00 / 修改時間：19:53:05" itemprop="dateCreated datePublished" datetime="2023-01-08T19:52:00+08:00">2023-01-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/natural-language-processing/" itemprop="url" rel="index"><span itemprop="name">自然語言處理</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>我們透過最具革新性且客製化的裝修結構，將兩片晶片合在一起。這種雙晶片的結構領先於現今業界的任何一種晶片。<br><strong>Apple Event, March 8, 2022, Introduction to Apple M1 Ultra</strong></p>
</blockquote>
<p>不知道你是否記得，我們在<a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/articles/10301346">圓圓圈圈圓圓～深度學習：循環神經網路 RNN</a>、<a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/articles/10302256">跟你我一樣選擇性記憶的神經網路？深度學習：長短期記憶 LSTM</a>，以及<a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/articles/10302765">每天成為更好的自己！神經網路也是！深度學習模型 GRU</a> 等三篇文章中有提到，因為這兩種神經網路模型都是由前到後地對資料進行「學習」，且相對於簡單的機器學習模型，神經網路有記憶特性，因此可以考慮到上下文的關係（儘管不同種神經網路有其各自的缺陷）。然而，LSTM 同樣也繼承著循環神經網路的其中一個缺點，而 GRU 雖然運算速度比較快，但作為 RNN 的一員，也是在劫難逃，而這個缺點就是<strong>無法考慮「下上文」的關係</strong>。</p>
<p>什麼意思？</p>
<h2 id="下上文的關係"><a href="#下上文的關係" class="headerlink" title="下上文的關係"></a>下上文的關係</h2><p>想像一下，我們要理解一段文字中的某一個字時，不只需要了解這個字的上一個字，有時候也會需要知道這個字的下一個字是什麼，才能確定這個字所真正代表的意義。舉例來說，讓我們看看以下這張圖：</p>
<p><img src="https://miro.medium.com/max/1218/1*wODEqmbZyAPH4lihCgpjdQ.gif"><br>source: <a target="_blank" rel="noopener" href="https://medium.com/@raghavaggarwal0089/bi-lstm-bc3d68da8bd0">Bi-LSTM</a></p>
<p>在圖中，單從前面的said並沒有辦法確定Teddy是什麼意思，因為Teddy有可能是一個人名（美國前總統 Teddy Roosevelt），也有可能是一種玩具（泰迪熊），而要確認Teddy指的是什麼，就會需要Teddy後面的字。比如說在這裡的狀況，若後面是bear，那就是一種玩具；若後面是大寫名詞，那代表這裡的Teddy很有可能是人名。</p>
<p>不然就是，左到右 LSTM 今天所學到的句子是「魯夫出海時搭著」，而右到左 LSTM 所學的是「打倒了近海王者」，那麼對於一個模型來說，有了上下文的資訊，就能比較準確地預測在中間的字是什麼吧！而對於RNN體系的單向神經網路來說，以上這些任務的表現就比較差了。</p>
<p>也就是說，<strong>我們前三天所介紹的三種模型：RNN、LSTM、GRU，都沒有辦法有效地解決這個問題</strong>。這時機器學習學家就想</p>
<blockquote>
<p>「那既然原來的LSTM是從左邊到右邊學習，那就再放另一條LSTM從右邊到左邊，就好啦！」</p>
</blockquote>
<p>當然我把它變得超級白話啦！但真的原理就是這麼簡單。所謂的BiLSTM，就是把從左到右的LSTM，以及從右到左的LSTM合在一起，就這樣！<del>不可能是什麼雙性戀的LSTM的吧，誰知道LSTM的自我認同是什麼呢？(X)</del> </p>
<p><img src="https://www.baeldung.com/wp-content/uploads/sites/4/2022/01/bilstm-1.png"></p>
<p>從圖中我們可以看到，每一個節點的輸出，都是左到右 LSTM 跟右到左 LSTM 所綜合的結果，這就是我們前面所說，<strong>單純將兩個方向的 LSTM 結合，其實就可以很有效地解決RNN體系無法理解「下上文」的缺陷。</strong></p>
<h2 id="問題與討論"><a href="#問題與討論" class="headerlink" title="問題與討論"></a>問題與討論</h2><p>所以 BiLSTM 通常也可以有效地解決各類的自然語言處理任務，像是文本分類、機器翻譯、實體辨識等等，除此之外，在聲音辨識中，BiLSTM也是可以佔有一席之地的喔！</p>
<p>不過熟悉我前面文章風格的都知道，接下來就要講不好的地方啦！俗話說：「有一好，沒兩好。」記得前面在講LSTM的時候，有提到因為在節點中加入了三個門閥（輸入閥、遺忘閥、輸出閥），所以<strong>不管是訓練時間還是運算資源，消耗量都相當可觀</strong>。那聰明的你可以想想看，兩條 LSTM 會怎麼樣呢？</p>
<p>沒錯，<strong>BiLSTM是個運算量更大、訓練時間更久的深度學習模型</strong>！你可能會想說，有LSTM就有BiLSTM，那有GRU，就會有BiGRU吧？是有BiGRU的，但通常大家都會直接轉向我們自然語言處理界的超大型巨人 BERT 了。也就是說，從明天開始，會花三篇的篇幅來，從注意機制（attention）開始，一路到transformer，接著到BERT的介紹，之後才會進入實作，還請大家一定要撐下去啊（其實是在對自己說）！</p>
<p>若大家沒事的話，也可以點進昨天的文章，不知道為什麼點閱率少得可憐啊！</p>
<blockquote>
<p>➡️ <a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/articles/10302765">【NLP】Day 17: 每天成為更好的自己！神經網路也是！深度學習模型 GRU</a><br>➡️ <a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/articles/10302256">【NLP】Day 16: 跟你我一樣選擇性記憶的神經網路？深度學習：長短期記憶 LSTM</a><br>➡️ <a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/articles/10301346">【NLP】Day 15: 圓圓圈圈圓圓～深度學習：循環神經網路 RNN</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://milanochuang.github.io/2023/01/08/%E3%80%90NLP%E3%80%91Day-17-%E6%AF%8F%E5%A4%A9%E6%88%90%E7%82%BA%E6%9B%B4%E5%A5%BD%E7%9A%84%E8%87%AA%E5%B7%B1%EF%BC%81%E7%A5%9E%E7%B6%93%E7%B6%B2%E8%B7%AF%E4%B9%9F%E6%98%AF%EF%BC%81%E6%B7%B1%E5%BA%A6%E5%AD%B8%E7%BF%92%E6%A8%A1%E5%9E%8B-GRU/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Hao Yun Chuang (Milan)">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="米蘭牛角尖">
      <meta itemprop="description" content="目前就讀於政大語言所，研究興趣為計算語言學<br/>">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 米蘭牛角尖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/01/08/%E3%80%90NLP%E3%80%91Day-17-%E6%AF%8F%E5%A4%A9%E6%88%90%E7%82%BA%E6%9B%B4%E5%A5%BD%E7%9A%84%E8%87%AA%E5%B7%B1%EF%BC%81%E7%A5%9E%E7%B6%93%E7%B6%B2%E8%B7%AF%E4%B9%9F%E6%98%AF%EF%BC%81%E6%B7%B1%E5%BA%A6%E5%AD%B8%E7%BF%92%E6%A8%A1%E5%9E%8B-GRU/" class="post-title-link" itemprop="url">【NLP】Day 17: 每天成為更好的自己！神經網路也是！深度學習模型 GRU</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2023-01-08 19:50:00 / 修改時間：19:51:14" itemprop="dateCreated datePublished" datetime="2023-01-08T19:50:00+08:00">2023-01-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/natural-language-processing/" itemprop="url" rel="index"><span itemprop="name">自然語言處理</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>今天沒有引言，但是有梗圖</p>
</blockquote>
<!-- ![](https://i.imgur.com/L5xk5fi.png) -->
<p><img src="https://i.imgur.com/4Nwatt5.png"></p>
<p>前天的文章介紹了基本的循環神經網路RNN，但RNN的致命缺點是容易導致梯度下降或是梯度爆炸。為了要解決這個問題，必須在以下兩點有所突破：</p>
<ol>
<li>優化梯度演算法</li>
<li>在神經網路的節點中，設計較好的激勵函數（activation function）</li>
</ol>
<p>昨天的文章所介紹的長短期記憶神經網路模型選擇往第二點的方向突破，在神經網路節點中加入了<strong>輸入閥（input gate）</strong>、<strong>遺忘閥（forget gate）</strong>、以及<strong>輸出閥（output gate）</strong>，這個做法可以有效地解決循環神經網路模型<strong>容易梯度下降或是梯度爆炸</strong>的缺點，但由於長短期記憶模型加入的參數過多，若透過大量的資料進行訓練，可能會導致<strong>模型運算量過大</strong>。那電腦科學家們為了降低運算成本以及減少佔用記憶體，同時又要維持相同的模型表現，於是就發明了<strong>GRU（Gate Recurrent Unit）</strong>。</p>
<h2 id="GRU"><a href="#GRU" class="headerlink" title="GRU"></a>GRU</h2><p>GRU 也是循環神經網路 RNN 的另外一種變體，因此網路架構也跟 RNN 相差無幾，GRU 同樣有輸入層、隱藏層、以及輸出層，最大的差別只是在於其中的節點運算。</p>
<p><img src="https://pic2.zhimg.com/80/v2-49244046a83e30ef2383b94644bf0f31_1440w.webp"></p>
<p>我們可以回想一下，在LSTM中，總共有三個門閥對資料進行「把關」，分別為<strong>輸入閥</strong>、<strong>遺忘閥</strong>，以及<strong>輸出閥</strong>；而在GRU中，同樣也有門閥，功能也是完全相同（皆為篩選記憶），只是三個變成了兩個，分別為<strong>重置閥</strong>（reset gate）以及<strong>更新閥</strong>，由於減少了門閥數量，因此運算量相對於LSTM來說，減輕了不少。</p>
<h3 id="GRU的內部結構"><a href="#GRU的內部結構" class="headerlink" title="GRU的內部結構"></a>GRU的內部結構</h3><p>跟LSTM相同，我們先從GRU的兩個門閥開始，圖中的 <img src="https://chart.googleapis.com/chart?cht=tx&chl=r" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=r"> 是重置閥，<img src="https://chart.googleapis.com/chart?cht=tx&chl=z" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=z"> 則為更新閥，兩者在各自的權重 <img src="https://chart.googleapis.com/chart?cht=tx&chl=W" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=W"> 乘上輸入 <img src="https://chart.googleapis.com/chart?cht=tx&chl=x%5Et" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=x%5Et"> 以及隱藏層 <img src="https://chart.googleapis.com/chart?cht=tx&chl=h%5E%7Bt-1%7D" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=h%5E%7Bt-1%7D"> 後，皆會經過激勵函數將數值變換成0-1之間的數字，篩選模型記憶的資訊，也就是說，這些數值代表節點對資訊的記憶程度。我們在這裡將 <img src="https://chart.googleapis.com/chart?cht=tx&chl=r" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=r"> 跟 <img src="https://chart.googleapis.com/chart?cht=tx&chl=z" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=z"> 計算出來之後，先放著備用。</p>
<p><img src="https://pic3.zhimg.com/80/v2-7fff5d817530dada1b279c7279d73b8a_1440w.webp"></p>
<p>接下來讓我們進入節點的設計，前面有說到 GRU 從原本 LSTM 的三個門閥變成兩個門閥，所以以下會分成兩個階段來講解。</p>
<h4 id="重置閥"><a href="#重置閥" class="headerlink" title="重置閥"></a>重置閥</h4><p>話不多說，先上圖！⊙ 代表矩陣相乘，⊕ 代表矩陣相加</p>
<!-- ![](https://i.imgur.com/KhfB9zz.jpg) -->
<p><img src="https://i.imgur.com/XFTckFV.jpg"></p>
<blockquote>
<p>請允許我把這部分用不到的路徑先遮蓋起來，這樣比較不容易迷路。</p>
</blockquote>
<p>在這裡，我們會用到之前所計算的重置閥 <img src="https://chart.googleapis.com/chart?cht=tx&chl=r" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=r">（reset gate）。首先，當我們得到了重置閥r之後，要透過重置閥來「重置」上一個隱藏層傳來的資訊： </p>
<p><img src="https://i.imgur.com/iIUe83D.png"></p>
<p>接著 <img src="https://chart.googleapis.com/chart?cht=tx&chl=h%5E%7B%7Bt-1%7D%5E%5Cprime%7D" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=h%5E%7B%7Bt-1%7D%5E%5Cprime%7D"> 與輸入 <img src="https://chart.googleapis.com/chart?cht=tx&chl=x%5Et" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=x%5Et">以及權重相乘後，再加入 <img src="https://chart.googleapis.com/chart?cht=tx&chl=tanh" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=tanh"> 的激勵函數，將資料壓到 [-1, 1] 之間，就會得到 <img src="https://chart.googleapis.com/chart?cht=tx&chl=h%5E%5Cprime" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=h%5E%5Cprime">。<br><img src="https://pic4.zhimg.com/80/v2-390781506bbebbef799f1a12acd7865b_1440w.webp"></p>
<ul>
<li><strong>代表意義</strong>：<img src="https://chart.googleapis.com/chart?cht=tx&chl=h%5E%5Cprime" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=h%5E%5Cprime"> 主要是透過 <img src="https://chart.googleapis.com/chart?cht=tx&chl=r" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=r"> 來篩選上一層隱藏層 <img src="https://chart.googleapis.com/chart?cht=tx&chl=h%5E%7Bt-1%7D" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=h%5E%7Bt-1%7D"> 所傳來的資訊，接著結合本節點的輸入 <img src="https://chart.googleapis.com/chart?cht=tx&chl=x%5Et" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=x%5Et"> 。以上動作都是<strong>為了將 <img src="https://chart.googleapis.com/chart?cht=tx&chl=h%5E%5Cprime" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=h%5E%5Cprime"> 加入到這個節點的隱藏狀態</strong>。功能類似於LSTM的選擇記憶階段。<!-- ![](https://i.imgur.com/2lJVxDZ.png) --></li>
</ul>
<h4 id="更新閥"><a href="#更新閥" class="headerlink" title="更新閥"></a>更新閥</h4><p><img src="https://i.imgur.com/FGNpyoA.jpg"></p>
<p>透過這個更新閥，就可以同時做到記憶以及遺忘的功能。在這裡，我們會用到之前所計算的更新閥 <img src="https://chart.googleapis.com/chart?cht=tx&chl=z" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=z">（update gate），在這裡的計算是：</p>
<p><img src="https://i.imgur.com/JnpJN2K.png"></p>
<p>其中更新閥的數值，因為sigmoid激勵函數的緣故，數值會介在[0, 1]之間，這代表GRU在這一層需要記憶的程度。<strong>越接近1代表記憶的資訊越多；越接近0代表遺忘的資訊越多。</strong> 不知你是否發現到，只要單單透過一個門閥，就可以<strong>同時控制遺忘以及選擇記憶</strong>，相對於LSTM要用多個門閥才能達到相同的效果，這就是為什麼GRU的計算成本可以低於LSTM的原因。</p>
<ul>
<li><strong>代表意義</strong>：<ul>
<li>「忘記」上一層隱藏狀態所帶來的資訊比例，主要是要放掉上一層隱藏層帶來的不重要資訊，功能接近於LSTM的遺忘閥（forget gate）。<br>  <img src="https://i.imgur.com/ymYxYbk.png"></li>
<li>表示從 <img src="https://chart.googleapis.com/chart?cht=tx&chl=h%5E%5Cprime" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=h%5E%5Cprime"> 中所要選擇記憶的比例。<br>  <img src="https://i.imgur.com/wYk3fCN.png"></li>
<li>兩者結合起來就是忘記上一層隱藏層 <img src="https://chart.googleapis.com/chart?cht=tx&chl=h%5E%7Bt-1%7D" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=h%5E%7Bt-1%7D"> 所傳下來的資訊，並從當節點所接收的輸入資料中進行選擇性記憶。<br>  <img src="https://i.imgur.com/RRH8Cgo.png"></li>
</ul>
</li>
</ul>
<h2 id="問題與討論"><a href="#問題與討論" class="headerlink" title="問題與討論"></a>問題與討論</h2><p>因為GRU用了比較少門閥的緣故，所以相對於長短期記憶LSTM來說，訓練的時間較短，佔用的記憶體也較少。只是模型表現上，兩者其實是差不多的。所以如果考量到訓練時間還有運算資源的限制的話，鐵定是毫不猶豫地選擇GRU的啦！</p>
<p><img src="https://i.imgur.com/FiOAAHy.jpg"></p>
<p>不過就像在<a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/articles/10301346">Day 15: 圓圓圈圈圓圓～深度學習：循環神經網路 RNN</a>中所說，這仍然無法解決模型無法理解下文與上文之間關係的問題。那人工智慧學家又是怎麼解決這個問題的呢？就讓我們等到明天介紹BiLSTM的文章再來聊吧！</p>
<p>若你有空，也歡迎來看看其他文章：</p>
<blockquote>
<p>➡️ <a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/articles/10302256">【NLP】Day 16: 跟你我一樣選擇性記憶的神經網路？深度學習：長短期記憶 LSTM</a><br>➡️ <a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/articles/10301346">【NLP】Day 15: 圓圓圈圈圓圓～深度學習：循環神經網路 RNN</a><br>➡️ <a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/articles/10300871">【NLP】Day 14: 神經網路也會神機錯亂？不，只會精神錯亂…深度學習：前饋神經網路</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://milanochuang.github.io/2023/01/08/%E3%80%90NLP%E3%80%91Day-16-%E8%B7%9F%E4%BD%A0%E6%88%91%E4%B8%80%E6%A8%A3%E9%81%B8%E6%93%87%E6%80%A7%E8%A8%98%E6%86%B6%E7%9A%84%E7%A5%9E%E7%B6%93%E7%B6%B2%E8%B7%AF%EF%BC%9F%E6%B7%B1%E5%BA%A6%E5%AD%B8%E7%BF%92%EF%BC%9A%E9%95%B7%E7%9F%AD%E6%9C%9F%E8%A8%98%E6%86%B6-LSTM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Hao Yun Chuang (Milan)">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="米蘭牛角尖">
      <meta itemprop="description" content="目前就讀於政大語言所，研究興趣為計算語言學<br/>">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 米蘭牛角尖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/01/08/%E3%80%90NLP%E3%80%91Day-16-%E8%B7%9F%E4%BD%A0%E6%88%91%E4%B8%80%E6%A8%A3%E9%81%B8%E6%93%87%E6%80%A7%E8%A8%98%E6%86%B6%E7%9A%84%E7%A5%9E%E7%B6%93%E7%B6%B2%E8%B7%AF%EF%BC%9F%E6%B7%B1%E5%BA%A6%E5%AD%B8%E7%BF%92%EF%BC%9A%E9%95%B7%E7%9F%AD%E6%9C%9F%E8%A8%98%E6%86%B6-LSTM/" class="post-title-link" itemprop="url">【NLP】Day 16: 跟你我一樣選擇性記憶的神經網路？深度學習：長短期記憶 LSTM</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2023-01-08 19:49:50 / 修改時間：19:50:09" itemprop="dateCreated datePublished" datetime="2023-01-08T19:49:50+08:00">2023-01-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>記憶是個很奇妙的東西。他並不如我想像中那樣運作的。我們太受限於時間了，尤其是時間的順序…<br><strong>《異星入境》Louise Banks</strong></p>
</blockquote>
<p>昨天我們剛介紹完循環神經網路（Recurrent Neural Network），提到說雖然循環神經網路很常被拿來利用在自然語言處理上，原因是因為循環神經網路有記憶的功能，可以考慮到輸入文本的上下文關係，並藉此來達到更好的效果。</p>
<p>但再厲害的技術，也都會有它優缺點，就如同我第一週所說的那樣，科學的演進都源自於對完美的追求，這也正是 Steven Pinker 在《再啟蒙的年代》一書中所說，只要是可以衡量的事物，而這些事物若是有所變化的，那就是人類社會便是一直在進步的路上邁進。</p>
<p>所以說同樣地，RNN 也有先天上的缺陷。像是因為過多層神經網路導致的梯度爆炸或是梯度消失，影響了模型學習成果以及表現，最後的準確度反倒下降了。昨天說到，LSTM 就是 RNN 的是日救星。</p>
<h2 id="長短期記憶模型（Long-Short-term-memory）"><a href="#長短期記憶模型（Long-Short-term-memory）" class="headerlink" title="長短期記憶模型（Long Short-term memory）"></a>長短期記憶模型（Long Short-term memory）</h2><p>這邊用一個簡單的例子再來重新解釋梯度爆炸跟梯度消失：假如說我們今天利用以下的資料訓練一個可以完成QA任務的循環神經網路。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">魯夫說他想成為海賊王</span><br></pre></td></tr></table></figure>

<p>在最後測試模型時，問了模型：「是誰想要成為海賊王？」。這時候可能會出現一個問題：</p>
<p>記不記得我們先前所說 RNN 的記憶特性，而會有這個特性正是因為模型也會將先前所學習的詞彙資訊（權重）在隱藏層中傳遞，最後才會得到的結果。之後，模型會將這個結果進行反向傳播，也就是模型在「反省」先前的學習成果時，都會乘上一個自己的參數 <img src="https://chart.googleapis.com/chart?cht=tx&chl=w_i" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=w_i">，若這個參數 <img src="https://chart.googleapis.com/chart?cht=tx&chl=w_i%3C1" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=w_i%3C1"> 的話，在資訊通過不同節點的過程中，若太多層神經網路，則會越乘越小，最後無限逼近於0，模型也就「忘記」先前所學的資訊，是為<strong>梯度消失</strong>；反之，若<img src="https://chart.googleapis.com/chart?cht=tx&chl=w_i%3E1" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=w_i%3E1">，某個資訊的概率也就越乘越大，而神經網路就被撐死了，是為<strong>梯度爆炸</strong>。</p>
<p><img src="https://programmathically.com/wp-content/uploads/2021/10/Screenshot-2021-10-29-at-15.21.19-1024x189.png"></p>
<p>由於「是誰想要成為海賊王？」的答案（魯夫）在訓練資料中幾乎是在最前面的位置。若模型產生梯度消失的現象，答案在訓練的過程中就會漸漸地被模型「忘記」，最後模型就無法正確回答問題的答案，準確率就下降了。而長短期記憶就可以有效解決這個問題。</p>
<h3 id="到底什麼是LSTM？"><a href="#到底什麼是LSTM？" class="headerlink" title="到底什麼是LSTM？"></a>到底什麼是LSTM？</h3><p>LSTM（Long Short-term memory），作為循環神經網路的一個變體，可以先從這張圖來理解，在這邊允許我借用左岸朋友莫煩大大的劇情比喻。</p>
<!-- ![](https://i.imgur.com/4G5veS4.png) -->
<!-- ![](https://i.imgur.com/iGAHTFV.png) -->
<p><img src="https://i.imgur.com/cnuDCQ3.png"></p>
<p>我們可以這麼理解，首先將藍色粗線視為電影的主線劇情、紅色線是為支線劇情，而輸入、忘記、以及輸出都是劇情的「把關者」。今天，「輸入把關者」在看電影時，會決定支線的劇情有多少對電影結局有影響，並依照劇情重要程度寫入主線劇情；但假如這些分線劇情會改變我們對於先前主線劇情的看法的話，「忘記把關者」就會將之前的主線劇情忘記，按照比例替換成現在的新劇情。也就是說，主線劇情的組成主要取決於「輸入把關者」跟「忘記把關者」。也就是說，相對於什麼都記，但時間一久就會忘記的單純循環神經網路，LSTM 則是會「選擇重點記，而且記得比較久」。</p>
<h4 id="熟悉概念後，我們來看看數學原理以及模型吧！"><a href="#熟悉概念後，我們來看看數學原理以及模型吧！" class="headerlink" title="熟悉概念後，我們來看看數學原理以及模型吧！"></a>熟悉概念後，我們來看看數學原理以及模型吧！</h4><p><img src="https://pic4.zhimg.com/80/v2-e4f9851cad426dfe4ab1c76209546827_1440w.webp"></p>
<p>這是台大李弘毅教授機器學習課程中的投影片。在圖中，我們可以看到左邊的是一般的循環神經網路，右邊的則是  LSTM。可以發現，兩者最大的差別就是，LSTM 多了一個變數 <img src="https://chart.googleapis.com/chart?cht=tx&chl=c%5Et" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=c%5Et">，稱為cell state，也就是前面所說的支線劇情。<img src="https://chart.googleapis.com/chart?cht=tx&chl=c%5Et" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=c%5Et"> 改變速度很慢且幅度小，而<img src="https://chart.googleapis.com/chart?cht=tx&chl=h" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=h"> 的改變速度則較快，而且幅度比較大。</p>
<p>在進入一個新節點時，總共得到四個狀態，分別是<img src="https://chart.googleapis.com/chart?cht=tx&chl=z" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=z">, <img src="https://chart.googleapis.com/chart?cht=tx&chl=z%5Ef" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=z%5Ef">, <img src="https://chart.googleapis.com/chart?cht=tx&chl=z%5Ei" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=z%5Ei">, <img src="https://chart.googleapis.com/chart?cht=tx&chl=z%5Eo" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=z%5Eo">。<img src="https://chart.googleapis.com/chart?cht=tx&chl=z" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=z"> 作為主要的資料輸入，而另外由激勵函數所包起來的 <img src="https://chart.googleapis.com/chart?cht=tx&chl=z%5Ei" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=z%5Ei">, <img src="https://chart.googleapis.com/chart?cht=tx&chl=z%5Eo" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=z%5Eo">, <img src="https://chart.googleapis.com/chart?cht=tx&chl=z%5Ef" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=z%5Ef">，則是作為前面所說把關的三個「門閥」。</p>
<!-- ![](https://pic4.zhimg.com/80/v2-15c5eb554f843ec492579c6d87e1497b_1440w.webp) -->
<!-- ![](https://pic1.zhimg.com/80/v2-d044fd0087e1df5d2a1089b441db9970_1440w.webp) -->
<p><img src="https://i.imgur.com/z9aXZdF.png"></p>
<p>而這四個狀態分別在長短期記憶的一個節點中，分別在運算的三個階段中扮演著不一樣的角色。先讓我們來看看以下這張圖，其中⊙代表矩陣相乘，⊕代表矩陣相加。（高中數學，還記得吧！）：</p>
<p><img src="https://pic2.zhimg.com/80/v2-556c74f0e025a47fea05dc0f76ea775d_1440w.webp"></p>
<p>在這張圖中的運算過程共分成三個階段：</p>
<ol>
<li><strong>忘記階段</strong><br>在這個階段會選擇性忘記上一個節點所傳來的資訊，簡單來說，就是決定「把重要的記起來，把不重要的忘記」。實際上的運算是，<img src="https://chart.googleapis.com/chart?cht=tx&chl=z%5E%7Bf%7D" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=z%5E%7Bf%7D">作為遺忘閥（forget gate），像篩子一樣，來控制上一個階段的<img src="https://chart.googleapis.com/chart?cht=tx&chl=c%5E%7Bt-1%7D" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=c%5E%7Bt-1%7D">哪些需要記得，哪些需要忘記。</li>
<li><strong>選擇記憶階段</strong><br>而在這個階段，LSTM 則會決定哪些是重要的資訊，而哪些不是，並將重點記起來。主要是透過輸入閥（input gate）<img src="https://chart.googleapis.com/chart?cht=tx&chl=z%5Ei" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=z%5Ei"> 來決定當前的輸入內容<img src="https://chart.googleapis.com/chart?cht=tx&chl=x%5Et" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=x%5Et">哪些是重點，哪些不是。<blockquote>
<p>以上兩者所得結果相加，就會是這個階段的<img src="https://chart.googleapis.com/chart?cht=tx&chl=c%5Et" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=c%5Et">。</p>
</blockquote>
</li>
<li><strong>輸出階段</strong><br>這個階段則是以前述兩者之和<img src="https://chart.googleapis.com/chart?cht=tx&chl=c%5Et" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=c%5Et">，經由激勵函數<img src="https://chart.googleapis.com/chart?cht=tx&chl=tanh" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=tanh">的縮放後，以<img src="https://chart.googleapis.com/chart?cht=tx&chl=z%5E0" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=z%5E0">來決定經過<img src="https://chart.googleapis.com/chart?cht=tx&chl=tanh" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=tanh">的 <img src="https://chart.googleapis.com/chart?cht=tx&chl=c%5Et" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=c%5Et">資訊中，有哪些適合做為當節點的輸出，並計算出下一個節點的 <img src="https://chart.googleapis.com/chart?cht=tx&chl=h%5Et" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=h%5Et">。</li>
</ol>
<h2 id="問題與討論"><a href="#問題與討論" class="headerlink" title="問題與討論"></a>問題與討論</h2><p>在過去讀書階段中，各位一定都有碰過兩種同學，一種是死命地想辦法將所有資訊記下來的同學，另一種則是只記重點，一些太枝微末節的小細節就會選擇性地放棄。而因為前者想要將所有東西都記下來，看起來好像很厲害，但時間一久反而會忘記最重要的重點，考試的表現就容易比較差，這種的大家通常都會說「沒有讀書方法」；反而是後者因為只記重點，所以記的東西就比較少，反而不容易忘記，考試的表現就會比前者還要好。</p>
<p>所以說，拉回來神經網路，比起 RNN 那樣死命地將所有的資訊記起來，不僅容易忘記先前所記下來的資訊，最後的表現也不會好；相對的 LSTM 會忘記不重要的資訊，只記得重要的，表現結果就會比較好。</p>
<h3 id="需要改進的地方"><a href="#需要改進的地方" class="headerlink" title="需要改進的地方"></a>需要改進的地方</h3><ol>
<li>語意限制：同樣是RNN的一種，所以也遺傳了RNN的其中一個缺點，詳見：<a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/articles/10301346">Day 15: 圓圓圈圈圓圓～深度學習：循環神經網路 RNN</a></li>
<li>訓練複雜度提升<br>相對於 RNN，我們光是看圖就可以發現，LSTM 其中新增了許多的參數，那一旦資料量提升，訓練複雜度也就會增加。而為了解決這個問題，資訊科學家又發明了與LSTM相同效果，訓練又較不複雜的 GRU（Gate Recurrent Unit），來搭建資料量大的模型，也就是我們明天的文章內容。</li>
</ol>
<p>下一篇文章</p>
<blockquote>
<p>➡️ <a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/articles/10302765">【NLP】Day 17: 每天成為更好的自己！神經網路也是！深度學習模型 GRU</a></p>
</blockquote>
<p>若你有空，也歡迎來看看其他文章</p>
<blockquote>
<p>➡️ <a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/articles/10301346">【NLP】Day 15: 圓圓圈圈圓圓～深度學習：循環神經網路 RNN</a><br>➡️ <a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/articles/10300871">【NLP】Day 14: 神經網路也會神機錯亂？不，只會精神錯亂…深度學習：前饋神經網路</a><br>➡️ <a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/articles/10300307">【NLP】Day 13: 可不可以再深一點點就好？深度學習基礎知識：你需要知道的這些那些</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://milanochuang.github.io/2023/01/08/%E3%80%90NLP%E3%80%91Day-15-%E5%9C%93%E5%9C%93%E5%9C%88%E5%9C%88%E5%9C%93%E5%9C%93%EF%BD%9E%E6%B7%B1%E5%BA%A6%E5%AD%B8%E7%BF%92%EF%BC%9A%E5%BE%AA%E7%92%B0%E7%A5%9E%E7%B6%93%E7%B6%B2%E8%B7%AF-RNN/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Hao Yun Chuang (Milan)">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="米蘭牛角尖">
      <meta itemprop="description" content="目前就讀於政大語言所，研究興趣為計算語言學<br/>">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 米蘭牛角尖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/01/08/%E3%80%90NLP%E3%80%91Day-15-%E5%9C%93%E5%9C%93%E5%9C%88%E5%9C%88%E5%9C%93%E5%9C%93%EF%BD%9E%E6%B7%B1%E5%BA%A6%E5%AD%B8%E7%BF%92%EF%BC%9A%E5%BE%AA%E7%92%B0%E7%A5%9E%E7%B6%93%E7%B6%B2%E8%B7%AF-RNN/" class="post-title-link" itemprop="url">【NLP】Day 15: 圓圓圈圈圓圓～深度學習：循環神經網路 RNN</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2023-01-08 19:48:00 / 修改時間：19:49:05" itemprop="dateCreated datePublished" datetime="2023-01-08T19:48:00+08:00">2023-01-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/natural-language-processing/" itemprop="url" rel="index"><span itemprop="name">自然語言處理</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>對啊，這也是一種世界。也是我心中的可能性。現在的我並不只是我，還可以有很多種自我。<br><strong>《新世紀福音戰士》碇真嗣</strong></p>
</blockquote>
<p>循環神經網路（Recurrent Neural Network），作為神經網路的其中一種變體，是在所有神經網路的模型中，最常被拿來應用在自然語言處理任務的模型之一。原因有二，首先，相對於其他的神經網路模型，循環神經網路模型的輸入資料較為彈性，意即當其他的神經網路只能接受固定的字數時，循環神經網路亦能透過<strong>不同長度的文本</strong>輸入進行訓練；二，語言中我們常說要了解上下文、語境，才能對語言有更完善的判斷，而循環神經網路的<strong>記憶功能</strong>就可以做到考慮文本上下文的效果。因為以上兩種原因，循環神經網路才會是所有神經網路中最常應用在自然語言處理上的深度學習模型。讓我們一起來看看為什麼吧！</p>
<h2 id="基本結構"><a href="#基本結構" class="headerlink" title="基本結構"></a>基本結構</h2><p>在正式進入架構之前，要先將循環神經網路跟其他神經網路進行區別。跟先前所介紹的神經網路模型相同，一個完整的循環神經網路模型同樣也有輸入層、隱藏層，以及輸出層，但既然基本架構都相同，那最關鍵的差異點在哪裡呢？我們先來觀察以下這兩張圖。上圖是人工神經網路，<img src="https://chart.googleapis.com/chart?cht=tx&chl=x" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=x">是輸入， <img src="https://chart.googleapis.com/chart?cht=tx&chl=y" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=y"> 是輸出；下圖則是循環神經網路， <img src="https://chart.googleapis.com/chart?cht=tx&chl=x" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=x"> 是輸入，<img src="https://chart.googleapis.com/chart?cht=tx&chl=o" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=o"> 則是輸出，其中<img src="https://chart.googleapis.com/chart?cht=tx&chl=s" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=s">是隱藏層。<br><img src="https://i.imgur.com/gueUHNo.png"><br>Credit: Speech and Language Processing<br><img src="https://miro.medium.com/max/1400/1*901chLVbYLHQLc5EeZWIAw.jpeg"><br>Credit: kdnuggets.com</p>
<p>不知道大家有沒有發現到，這兩張圖之中最大的差異就在於，循環神經網路的隱藏層會自我循環，也就是說，若將隱藏層拆開來看的話，<strong>隱藏層中的節點會接收上一個隱藏層節點所傳過來的權重</strong>。也就是說，對資料的每一個節點來說，就像是碇真嗣所說：「現在的我並不只是我，同時也包含了過去到現在的很多種自我。」所以我們重新回來看神經網路的圖示架構可以發現，正是因為這樣的特性，循環神經網路才有記憶的功能。</p>
<p>理解循環神經網路最大的特色之後，再讓我們回來看其中的數學運算原理。其實除了隱藏層之間的連接特性之外，循環神經網路的計算也跟一般的神經網路大同小異。首先是輸入資料<img src="https://chart.googleapis.com/chart?cht=tx&chl=x_t" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=x_t">與權重<img src="https://chart.googleapis.com/chart?cht=tx&chl=W" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=W">相乘，接著再跟上一個隱藏層神經元所學習到的資訊<img src="https://chart.googleapis.com/chart?cht=tx&chl=h_%7Bt-1%7D" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=h_%7Bt-1%7D">與權重<img src="https://chart.googleapis.com/chart?cht=tx&chl=U" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=U">相乘，再把兩者相加，把相加之後的值加入激勵函數<img src="https://chart.googleapis.com/chart?cht=tx&chl=g" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=g">，稱為當下隱藏層的輸出<img src="https://chart.googleapis.com/chart?cht=tx&chl=h_t" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=h_t">，接著當下的輸出層即是隱藏層輸出乘上另一個權重<img src="https://chart.googleapis.com/chart?cht=tx&chl=V" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=V">，再經由激勵函數產生輸出<img src="https://chart.googleapis.com/chart?cht=tx&chl=y_t" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=y_t">。</p>
<!-- ![](https://i.imgur.com/gghC3Mp.png) -->
<p><img src="https://i.imgur.com/pNfPyIB.png"></p>
<h3 id="應用"><a href="#應用" class="headerlink" title="應用"></a>應用</h3><p>除此之外，循環神經網路彈性的輸入與輸出特性，也讓我們在各種下游任務間來去自如，其輸入與輸出及對應的功能如下：</p>
<ol>
<li><strong>一對一（one to one）</strong>：輸入（input）及輸出（output）皆為固定，例如文本分類時輸出機率等。</li>
<li><strong>一對多（one to many）</strong>：單一的輸入，但是可以有複數個輸出，例如文本生成，給予一個主題，使模型透過這個主題生成一串文本。</li>
<li><strong>多對一（many to one）</strong>：多個輸入，但只有單一輸出，例如情感分析(Sentiment Analysis)，我們可以輸入任一一段文字，並使模型判斷這段文字正面以及負面情緒的程度。</li>
<li><strong>多對多（many to many）</strong>：複數個輸入，複數個輸出，例如機器翻譯(Machine Translation)，輸入一段外國語言的句子，模型將這段話翻譯成中文。</li>
</ol>
<h2 id="問題與限制"><a href="#問題與限制" class="headerlink" title="問題與限制"></a>問題與限制</h2><ul>
<li><strong>語意限制</strong><br>前面提過，循環神經網路有記憶的特性，因此可以將上下文也考慮進去。但其實嚴格來說，如你們在圖中所見，隱藏層中的節點只能接收<strong>上一個隱藏層的節點</strong>，沒有辦法同時也接收<strong>下一個隱藏層節點</strong>的資訊。聽起來很抽象，但這其實就意味著模型雖然可以記住上文，並消化下文，但卻也因為這個特性，使得模型無法理解下文與上文之間的關係。</li>
<li><strong>梯度消失</strong><br>當神經網路在反向傳播中，也就是模型向回修正，並透過梯度下降法在找尋最佳解，找Loss的最小值時，可能會發生一個現象，就是梯度會越來越小、越來越小，最後變為零。這就導致模型沒有辦法再繼續找到最小的Loss。</li>
<li><strong>梯度爆炸</strong><br>梯度爆炸正好與梯度消失相反，梯度會越來越大、越來越大，導致越接近淺層網路，權重變化就越大，也會造成模型訓練上的反效果。</li>
</ul>
<p>那該如何解決梯度消失以及梯度爆炸的問題呢？其實一般來說，在自然語言處理的任務中，不會僅僅只用循環神經網路，也會在裡面再加上另外一層深度學習模型：<strong>長短期記憶（LSTM）</strong>。同時應用循環神經網路以及長短期記憶模型，就可以有效避免梯度消失以及爆炸的問題了。</p>
<p>那我們明天就相約在長短期記憶見囉！</p>
<p>下一篇文章</p>
<blockquote>
<p>➡️ <a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/articles/10302256">【NLP】Day 16: 跟你我一樣選擇性記憶的神經網路？深度學習：長短期記憶 LSTM</a></p>
</blockquote>
<p>若你有空，也歡迎來看看其他文章</p>
<blockquote>
<p>➡️ <a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/articles/10300871">【NLP】Day 14: 神經網路也會神機錯亂？不，只會精神錯亂…深度學習：前饋神經網路</a><br>➡️ <a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/articles/10300307">【NLP】Day 13: 可不可以再深一點點就好？深度學習基礎知識：你需要知道的這些那些</a><br>➡️ <a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/articles/10299617">【NLP】Day 12: 豬耳朵餅乾跟機器學習也有關係？機器學習：羅吉斯回歸</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://milanochuang.github.io/2023/01/08/%E3%80%90NLP%E3%80%91Day-14-%E7%A5%9E%E7%B6%93%E7%B6%B2%E8%B7%AF%E4%B9%9F%E6%9C%83%E7%A5%9E%E6%A9%9F%E9%8C%AF%E4%BA%82%EF%BC%9F%E4%B8%8D%EF%BC%8C%E5%8F%AA%E6%9C%83%E7%B2%BE%E7%A5%9E%E9%8C%AF%E4%BA%82-%E6%B7%B1%E5%BA%A6%E5%AD%B8%E7%BF%92%EF%BC%9A%E5%89%8D%E9%A5%8B%E7%A5%9E%E7%B6%93%E7%B6%B2%E8%B7%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Hao Yun Chuang (Milan)">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="米蘭牛角尖">
      <meta itemprop="description" content="目前就讀於政大語言所，研究興趣為計算語言學<br/>">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 米蘭牛角尖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/01/08/%E3%80%90NLP%E3%80%91Day-14-%E7%A5%9E%E7%B6%93%E7%B6%B2%E8%B7%AF%E4%B9%9F%E6%9C%83%E7%A5%9E%E6%A9%9F%E9%8C%AF%E4%BA%82%EF%BC%9F%E4%B8%8D%EF%BC%8C%E5%8F%AA%E6%9C%83%E7%B2%BE%E7%A5%9E%E9%8C%AF%E4%BA%82-%E6%B7%B1%E5%BA%A6%E5%AD%B8%E7%BF%92%EF%BC%9A%E5%89%8D%E9%A5%8B%E7%A5%9E%E7%B6%93%E7%B6%B2%E8%B7%AF/" class="post-title-link" itemprop="url">【NLP】Day 14: 神經網路也會神機錯亂？不，只會精神錯亂...深度學習：前饋神經網路</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2023-01-08 19:47:00 / 修改時間：19:48:05" itemprop="dateCreated datePublished" datetime="2023-01-08T19:47:00+08:00">2023-01-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>在夜城，不要相信任何人，受到背叛也是自己的錯…<br><strong>琦薇《電馭叛客：邊緣行者》</strong></p>
</blockquote>
<p>我很喜歡賽博龐克風格的相關作品，像是銀翼殺手、攻殼機動隊，都是我很愛的作品。最近在看《電馭叛客：邊緣行者》（好看，推薦大家去看），在動畫中，或是說在賽博龐克風格作品中的人物，為了要達到更高更強大的身體能力，會用電子零件（像是電子手臂，或是增快移動速度的軍事武器植入物等）將身體的一部分改造。而在電馭叛客中有個名詞：<em>神機錯亂</em>，意指若身上已經乘載過多改裝與植入，這些電子組件會侵蝕人性，並擾亂心智，到最後迷失自我。</p>
<p>最近在寫神經網路的我，突然覺得神經網路跟神機錯亂真像。在一開始，疊了一層兩層的神經網路，得到了還算可以（夠用）的結果，但為了要達到更高的準確度、更好的表現，疊了更多層的神經網路上去，卻在梯度下降找最佳解時，碰到梯度爆炸或是梯度消失的問題，最後就一直徘徊在局部最小值的谷底出不來，然後他就停止學習了，<strong>不就很像神機錯亂嗎？</strong></p>
<p><img src="https://cdn.oneesports.gg/cdn-data/2022/07/CyberpunkEdgerunners_hack.jpg"></p>
<p>扯遠了<del>不可能每次都扯遠吧</del>，今天首先要介紹的是前饋神經網路，若說機器學習的第一個模型是貝氏分類模型，那麼深度學習就一定要從前饋神經網路開始講起。首先會先從神經網路的基本結構開始，一直到自然語言處理實務上的操作，話不多說，就讓我們開始吧！</p>
<h2 id="神經網路的結構"><a href="#神經網路的結構" class="headerlink" title="神經網路的結構"></a>神經網路的結構</h2><p>神經網路的基本架構大致上可以分成三個部分：</p>
<ul>
<li><strong>輸入層（input layer）</strong>：初步資料會先經過輸入層進行處理。在自然語言處理中通常會是傳遞給embedding layer的one-hot vector。</li>
<li><strong>隱藏層（hidden layer）</strong>：隱藏層可以有一層以上，在隱藏層中，會透過「權重」計算輸出。通常隱藏層會篩選出多餘的資訊，並將所習得之重要資訊傳遞給下一層隱藏層。</li>
<li><strong>輸出層（output layer）</strong>：學習成果，通常會是以機率的形式呈現。</li>
</ul>
<h3 id="神經元"><a href="#神經元" class="headerlink" title="神經元"></a>神經元</h3><p>這些神經層中，是由一個一個的節點組成，這些節點有時候也會被稱為 <strong>「神經元」（neuron）</strong> ，這些節點其實就是將<strong>特徵乘上權重</strong>，再加上一個偏項b，那麼很多個節點所組成的神經網路，事實上也就是很多個函式所組成的函式組！</p>
<!-- ![](https://i.imgur.com/u7qOiHj.png) -->
<p><img src="https://i.imgur.com/zXooHW7.png"></p>
<p>有沒有覺得很熟悉，因為這個計算方式跟羅吉斯迴歸<strong>一模模一樣樣！！！</strong> 也就是當時在羅吉斯迴歸時所說的<strong>計算原始分數</strong>，再將我們計算的z值，也就是原始分數，放入<strong>激勵函數</strong>，將線性解轉換成非線性解，因為有些狀況之下，線性解並無法解決。</p>
<p><img src="https://i.imgur.com/1BPTrAt.png"></p>
<p>比如說像以上這種狀況，要畫一條線把藍點跟白點分開，左邊數過來第一張圖跟第二張圖都可以只利用一條線將兩者區別，但難保現實中會有第三張圖，這時候就會需要非線性解來幫助我們解決這種類型的問題。</p>
<h3 id="激勵函數"><a href="#激勵函數" class="headerlink" title="激勵函數"></a>激勵函數</h3><p>我們在前幾天有討論過Sigmoid以及Softmax，這裡就先不贅述，若遺漏掉那部份的可以回去看我之前的<a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/articles/10299617">文章</a>。今天要來討論另外兩個激勵函數，也就是tanh 以及Rectified Linear Unit（ReLU）。<br><img src="https://i.imgur.com/UKx4SaC.png"><br>A圖是tanh，B圖是ReLU，一樣也是各有優缺點。</p>
<ul>
<li><strong>tanh函式</strong>：在接近上下界時也趨近於平，所以也能像Sigmoid一樣擅長處理離群值，另外一樣也可以微分，記得先前所說找最佳解時，可不可微是很重要的特性，<del>通常我們希望可微啦，人稱<strong>欲可微</strong></del>。</li>
<li><strong>ReLU</strong>：結果可以非常接近線性。</li>
</ul>
<blockquote>
<p>但像是Sigmoid或是tanh這種上下界趨平的函式，一階導數很有可能接近於零，接近零的結果，就是在進行梯度下降時發現梯度不見，模型也停止學習了，這就是所謂的<strong>梯度消失（gradient vanishing）</strong></p>
</blockquote>
<h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><p>詳見我先前的文章：<a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/articles/10299617">【NLP】Day 12: 豬耳朵餅乾跟機器學習也有關係？機器學習：羅吉斯回歸</a></p>
<h3 id="Error-backpropagation"><a href="#Error-backpropagation" class="headerlink" title="Error backpropagation"></a>Error backpropagation</h3><p>神經網路有另外一個優點是，如果發現錯誤，模型會往回修正。但這部分有點複雜，我們在之後的文章再詳細介紹。</p>
<h2 id="自然語言處理的運作"><a href="#自然語言處理的運作" class="headerlink" title="自然語言處理的運作"></a>自然語言處理的運作</h2><p>自然語言處理上的神經網路又有一點不一樣，在這裡為了處理訓練資料中所沒有的資料，會再多一個嵌入層（embedding layer）。<br><img src="https://i.imgur.com/YKY4TsI.png"></p>
<ol>
<li><strong>輸入層（input layer）</strong>：one-hot vector<br>自然語言處理的第一層神經網路通常會是one-hot vector，通常是為了標注其在嵌入層中的位置，藉此幫助模型更好理解語意。假如說今天<code>海賊王</code>在embedding layer中的第三個位置，並假設embedding layer的矩陣維度為5，那麼one-hot vector就會是<code>[0, 0, 1, 0, 0]</code>。</li>
<li><strong>嵌入層（embedding layer）</strong><br>記得在講Word2Vec時（忘記的話可以回去複習 <a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/articles/10297745">Day 9: 又是國王皇后的例子啦！Word2Vec、N-Gram</a>，我這篇的點閱率低的可憐。）我們有提到可以訓練一個word embedding，讓電腦了解語意間的關係，但是要注意這裡的語意關係很吃訓練資料的領域跟品質。這麼一來，即使出現了模型先前沒「看」過的字，透過這個embedding也能較好地處理這類的問題。比如說： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">training data: 索隆/跟/龍馬/拿/劍/決鬥</span><br><span class="line">test data: 鷹眼/跟/比斯塔/用/劍/對決</span><br></pre></td></tr></table></figure>
 即使模型沒有在訓練資料看過鷹眼，但是因為Word embedding，我們可以推斷「索隆」跟「鷹眼」有很近的「語意關係」（可能因為都是劍客？），所以還是能推斷「鷹眼」後面可能會出現的字，跟「索隆」很接近。</li>
<li><strong>隱藏層（hidden layer）</strong><br>再次乘上學習過後的權重。</li>
<li><strong>輸出層（output layer）</strong>：activation function<br>同樣就是透過激勵函數輸出成機率，詳見前文。</li>
</ol>
<p>就是這樣，明天見！</p>
<p>下一篇文章</p>
<blockquote>
<p>➡️ <a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/articles/10302256">【NLP】Day 15: 跟你我一樣選擇性記憶的神經網路？深度學習：長短期記憶 LSTM</a></p>
</blockquote>
<p>若你有空，也歡迎來看看其他文章</p>
<blockquote>
<p>➡️ <a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/articles/10300307">【NLP】Day 13: 可不可以再深一點點就好？深度學習基礎知識：你需要知道的這些那些</a><br>➡️ <a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/articles/10299617">【NLP】Day 12: 豬耳朵餅乾跟機器學習也有關係？機器學習：羅吉斯回歸</a><br>➡️ <a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/articles/10298847">【NLP】Day 11: 什麼？妳男友有乾妹妹？那你很大機率被綠了！機器學習：貝氏分類器</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://milanochuang.github.io/2023/01/08/%E3%80%90NLP%E3%80%91Day-13-%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E5%86%8D%E6%B7%B1%E4%B8%80%E9%BB%9E%E9%BB%9E%E5%B0%B1%E5%A5%BD%EF%BC%9F%E6%B7%B1%E5%BA%A6%E5%AD%B8%E7%BF%92%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98%EF%BC%9A%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E9%80%99%E4%BA%9B%E9%82%A3%E4%BA%9B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Hao Yun Chuang (Milan)">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="米蘭牛角尖">
      <meta itemprop="description" content="目前就讀於政大語言所，研究興趣為計算語言學<br/>">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 米蘭牛角尖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/01/08/%E3%80%90NLP%E3%80%91Day-13-%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E5%86%8D%E6%B7%B1%E4%B8%80%E9%BB%9E%E9%BB%9E%E5%B0%B1%E5%A5%BD%EF%BC%9F%E6%B7%B1%E5%BA%A6%E5%AD%B8%E7%BF%92%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98%EF%BC%9A%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E9%80%99%E4%BA%9B%E9%82%A3%E4%BA%9B/" class="post-title-link" itemprop="url">【NLP】Day 13: 可不可以再深一點點就好？深度學習基礎知識：你需要知道的這些那些</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2023-01-08 19:46:47 / 修改時間：19:47:08" itemprop="dateCreated datePublished" datetime="2023-01-08T19:46:47+08:00">2023-01-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>人類與動物的學習大都是非監督學習。所以說如果「智慧」是一塊蛋糕，那麼非監督學習才是蛋糕本體，監督學習則是那層糖霜，強化學習不過是上頭的櫻桃。<br>Most of human and animal learning is unsupervised learning. If intelligence was a cake, unsupervised learning would be the cake, supervised learning would be the icing on the cake, and reinforcement learning would be the cherry on the cake.<br><strong>楊立昆 Yann LeCun</strong></p>
</blockquote>
<p>不知道昨天大家有沒有看到一則<del>偏宅</del>的新聞，就是星際大戰中達斯維達的配音員詹姆士・厄爾・瓊斯（James Earl Jones），從今開始正式不再為達斯維達配音。我們再也沒有機會聽到本人講那經典的台詞：</p>
<p><img src="https://media.giphy.com/media/xT9DPpf0zTqRASyzTi/giphy.gif"></p>
<p><del>喔，對了，防雷警報，達斯維達其實是路克・天行者的老爸。（誰在乎？）</del></p>
<p>但是新聞還說，雖然本人不再配音，我們在電影中仍然還是可以聽得到他那經典的呼氣聲，並感受它強大的原力？為什麼？這一切都拜那個離我們又遙遠又接近的深度學習技術所賜。</p>
<p>其實不僅僅是語音合成，文本處理上現在也很流行利用深度學習的技術來完成任務。今天，就讓我們先來簡單大概了解什麼是深度學習，<del>還有大家在吵什麼</del>。</p>
<h2 id="釐清名詞觀念"><a href="#釐清名詞觀念" class="headerlink" title="釐清名詞觀念"></a>釐清名詞觀念</h2><p>在開始之前，我們得要先釐清名詞觀念。從以前到現在，我們已經學到了好多名詞：人工智慧、機器學習、深度學習、監督式學習、非監督式學習，那這些名詞之間到底有什麼不一樣呢？我們可以這樣理解：</p>
<p><img src="https://blogs.nvidia.com/wp-content/uploads/2016/07/Deep_Learning_Icons_R5_PNG.jpg.png.webp"><br>Source: <a target="_blank" rel="noopener" href="https://blogs.nvidia.com/blog/2016/07/29/whats-difference-artificial-intelligence-machine-learning-deep-learning-ai/">NVIDIA</a></p>
<p>人工智慧是一個「雨傘術語」（umbrella term），而機器學習則是人工智慧底下最廣為人知的一個分支。主要目的在於設計和分析一些讓電腦可以自動「學習」的演算法，並利用規律對未知資料進行預測。機器學習又是另外一個「雨傘術語」，因為機器學習又根據演算法分為很多種不同的學習方法，我們這邊提到了監督式學習跟非監督式學習，如果沒看過我之前針對兩者差別進行的介紹，可以去看這篇 **<a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/articles/10298197">Day 10: 進入偉大航道！機器學習基礎知識：你需要知道的這些那些</a>**。而深度學習是機器學習的其中一種方式。</p>
<h2 id="什麼是深度學習？"><a href="#什麼是深度學習？" class="headerlink" title="什麼是深度學習？"></a>什麼是深度學習？</h2><p>深度學習作為機器學習的其中一個分支，若要「沒那麼精確」但要淺顯易懂的解釋，你可以將深度學習理解成「比較深的神經網路」目的在於將資料放進多個節點，經過線性以及非線性的轉換，從原始資料中自動抽取足以代表資料的特徵，自動抽取特徵這點又被稱為<strong>表徵學習</strong>（representation learning），最終都可以得到非常優秀的結果。</p>
<p>類神經網路通常會有好幾層，每一層會有許多個節點（perceptron），就像人類的神經系統中，神經元與神經元之間的連結一樣，節點與節點之間也會彼此傳遞資訊，之後再經過激勵函數（activation function）轉換成輸出。</p>
<h3 id="為什麼深度學習逐漸變成主流？"><a href="#為什麼深度學習逐漸變成主流？" class="headerlink" title="為什麼深度學習逐漸變成主流？"></a>為什麼深度學習逐漸變成主流？</h3><p>但其實深度學習的歷史已經非常悠久了。早在六七零年代，就有電腦科學家嘗試重現生物神經網路的架構，希望電腦可以達到跟人類一樣的優秀學習能力。但礙於當時電腦的運算能力還跟不上理論，再加上數位化的資料並不多，無法提供神經網路好的學習資源，所以當時神經網路仍無法展露頭角。</p>
<p>但現在拜於網路與資訊技術的進步，有越來越多的數位資料可以提供這些神經網路小試身手，除此之外，逐漸成熟的GPU演算技術也幫助了神經網路的運算，速度也有大幅成長（但仍然很慢），天時地利人和之下，神經網路這個名詞才漸漸重新浮出檯面。</p>
<h3 id="跟前面提到的機器學習有什麼不一樣？"><a href="#跟前面提到的機器學習有什麼不一樣？" class="headerlink" title="跟前面提到的機器學習有什麼不一樣？"></a>跟前面提到的機器學習有什麼不一樣？</h3><p><img src="https://i.imgur.com/jQ2IzW7.png"><br>一般來說，像是我們先前所說的貝氏分類以及羅吉斯回歸這樣的監督式機器學習，都會需要我們手動加入特徵，而這些特徵都是透過我們人類觀察而得的；人工神經網路乃至於深度學習，其實並不需要我們人類進行特徵工程，深度學習模型會自己學習特徵並自動分類，最後輸出分類，但模型找的特徵可能跟我們一般所認知的特徵會有點差距就是了，也就是說，我們會看不懂神經網路找到的特徵。因此，人工神經網路也是黑盒子模型的一種，這部分後面我們會再提。</p>
<p><img src="https://miro.medium.com/max/1400/0*LFr2lyb_FzhwT8he.png"></p>
<p>也就是說，資料越多，神經網路所能夠學的特徵就越多，深度學習模型的表現也就越好，好過過去監督式的機器學習模型。</p>
<h2 id="可不可以再深一點點就好？越深越好？"><a href="#可不可以再深一點點就好？越深越好？" class="headerlink" title="可不可以再深一點點就好？越深越好？"></a>可不可以再深一點點就好？越深越好？</h2><p>深度學習的一個很常被討論的問題就是，既然叫深度學習，是不是越深就越好？現代知名電腦科學家楊立昆（Yann LeCun）在2008年的論文 <a target="_blank" rel="noopener" href="http://yann.lecun.com/exdb/publis/pdf/bengio-lecun-07.pdf">Scaling Learning Algorithms towards AI</a> 中就提到，在特定資料量底下，淺層架構的神經網路運算上或許沒辦法達到它最好的表現，深層才能達到最大效益。台大李宏毅老師在機器學習課程中也有提到，神經網路好像疊越多層、神經元越多，表現就越好。那我們就這樣一直無腦疊下去就好了嗎？模型就會越好嗎？<br><img src="https://i.imgur.com/hSJwdHz.png"></p>
<h3 id="深度的特性反而是一把雙面刃？"><a href="#深度的特性反而是一把雙面刃？" class="headerlink" title="深度的特性反而是一把雙面刃？"></a>深度的特性反而是一把雙面刃？</h3><p>後面我們會提到加深神經網路在優化上可能會發生的問題，比如像是神經網路的運算時間計算量大、耗時，<a target="_blank" rel="noopener" href="https://proceedings.neurips.cc/paper/1988/file/3def184ad8f4755ff269862ea77393dd-Paper.pdf">即使是一個兩層三節點的神經網路，時間消耗仍然為NP-Complete</a>，NP-Complete就是運行複雜程度的等級，詳細可以來看這篇前輩的<a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/articles/10237364">文章</a>。另外，也因為梯度消失以及梯度爆炸的現象（後面文章會介紹），也會導致神經網路找不到最佳解，你可以回想前面我們說羅吉斯迴歸為凸函數，找得到最小值；但神經網路為非凸函數，有可能只找到局部最小值，那該怎麼辦呢？</p>
<p>答案是，不怎麼辦！因為我們不能保證模型找到最佳解，但是找到的最小值已經非常逼近最佳解，也就是說已經夠好到足以幫助人類完成許多任務了！</p>
<p>所以其實還是老話一句，越深越好？還是要看任務是什麼，找到最適合的方法才是最重要的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://milanochuang.github.io/2023/01/08/%E3%80%90NLP%E3%80%91Day-12-%E8%B1%AC%E8%80%B3%E6%9C%B5%E9%A4%85%E4%B9%BE%E8%B7%9F%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92%E4%B9%9F%E6%9C%89%E9%97%9C%E4%BF%82%EF%BC%9F%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92%EF%BC%9A%E7%BE%85%E5%90%89%E6%96%AF%E5%9B%9E%E6%AD%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Hao Yun Chuang (Milan)">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="米蘭牛角尖">
      <meta itemprop="description" content="目前就讀於政大語言所，研究興趣為計算語言學<br/>">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 米蘭牛角尖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/01/08/%E3%80%90NLP%E3%80%91Day-12-%E8%B1%AC%E8%80%B3%E6%9C%B5%E9%A4%85%E4%B9%BE%E8%B7%9F%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92%E4%B9%9F%E6%9C%89%E9%97%9C%E4%BF%82%EF%BC%9F%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92%EF%BC%9A%E7%BE%85%E5%90%89%E6%96%AF%E5%9B%9E%E6%AD%B8/" class="post-title-link" itemprop="url">【NLP】Day 12: 豬耳朵餅乾跟機器學習也有關係？機器學習：羅吉斯回歸 </a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2023-01-08 19:45:00 / 修改時間：19:45:57" itemprop="dateCreated datePublished" datetime="2023-01-08T19:45:00+08:00">2023-01-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/natural-language-processing/" itemprop="url" rel="index"><span itemprop="name">自然語言處理</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>麵粉、砂糖、水、植物油為主，其它成份則視做法及口感需求而有不同。餅乾之所以會出現螺旋線，這是由於兩種顏色的麵糰桿成皮狀，再將彼此疊合而捲成柱狀，以刀切割成每一片厚度相當的餅乾，就可以看出每一片餅乾都帶有螺旋線，經過烘烤後成形，即可食用。<br>維基百科《螺仔餅》</p>
</blockquote>
<p>我先承認我真的沒梗，引言就找這個了XD</p>
<p>昨天我們講到了貝氏分類器，希望大家都有稍微理解機器學習模型大概會是以什麼方式呈現。我們在進入羅吉斯回歸的模型之前，先來回顧一下所謂的機率性機器學習分類器（probabilistic machine learning classifier）的大致組成吧，其實幾乎所有的機器學習模型都是依循這樣的模式在進行分類的，即便是神經網路也是幾乎雷同，而自然語言處理的模型也不排除在外。</p>
<h2 id="模型架構"><a href="#模型架構" class="headerlink" title="模型架構"></a>模型架構</h2><ul>
<li><strong>特徵輸入</strong><br>將資料整理成機器學習模型可以理解的形式，首先就是要將這些文字轉換成數字，相信大家都還記得。那其實這種所謂「不同種將文字轉成數字」的方式，也有個專有名詞，稱為<strong>特徵工程（feature engineering）</strong>，特徵工程所得之資料即可作為特徵輸入至模型。</li>
<li><strong>換算機率</strong><br>完成前面的特徵工程之後，會得到一系列的特徵相關數字，由於這些數字並不是模型的理想輸出（因為記得前面所提模型需要輸出的是<em>分類的機率</em>）所以會經過一系列的數學運算過後，得到最後為0~1之間的機率呈現。</li>
<li><strong>最大化與正確答案相符的可能性（Log-likelihood &amp; Loss function）</strong><br>接著得到的機率有可能也不會是最好的答案，因為我們需要最小化所謂的損失函數，那要最小化的話，可以透過梯度下降的方式來求得最佳解。<ul>
<li>損失函數</li>
<li>梯度下降</li>
</ul>
</li>
</ul>
<h2 id="羅吉斯回歸"><a href="#羅吉斯回歸" class="headerlink" title="羅吉斯回歸"></a>羅吉斯回歸</h2><h3 id="特徵輸入"><a href="#特徵輸入" class="headerlink" title="特徵輸入"></a>特徵輸入</h3><p>在自然語言處理的領域中，除了可以透過<strong>直覺</strong>來判斷文本中可能的特徵之外，<strong>不同領域的文本</strong>也會有他們各自的特徵（比如說，前一陣子很有名的霸社，或者是將官首文化中的文本，可能就會有屬於其次文化的特殊語言特徵）；另外，近期流行的自然語言處理方式，也會透過先前所說的 <strong>Word embedding</strong> 的方式作為特徵加入BERT語言模型中。</p>
<h3 id="利用特徵計算原始分數"><a href="#利用特徵計算原始分數" class="headerlink" title="利用特徵計算原始分數"></a>利用特徵計算原始分數</h3><p>經過特徵工程之後，我們會得到一串數字（或是向量vector）羅吉斯回歸的第一步，就是先將這些向量x與權重 w（weight）進行內積（dot product）<del>是不是又出現另外一個熟悉的名詞？</del> ，內積過後得到的數字再加上 b （bias term, a.k.a intercept），這是為了避免有些過度表現的特徵影響了模型的判斷。</p>
<p><img src="https://i.imgur.com/q26xFAQ.png"></p>
<p>我會稱這段過程為<strong>計算原始分數</strong>。現在說考學測應該還不會暴露年齡吧？你可以這麼理解，我們計算的這個原始分數代表<strong>文章是正面或是負面的可能「程度」</strong>，就像是學測考完都會有一個「原始分數」。但這個所謂的程度或是原始分數，不是我們想要的結果，對吧？因為我們想要的是<strong>這個文本的可能是正面或是負面的「機率」是多少</strong>，就像是我們想要知道學測的「級分」，因為「級分」的高低才真正代表表現的好壞。為了要讓模型輸出機率，會再將這個「原始分數」加入激勵函數（activation function）將輸出數值轉換成機率。</p>
<h3 id="利用激勵函數換算機率"><a href="#利用激勵函數換算機率" class="headerlink" title="利用激勵函數換算機率"></a>利用激勵函數換算機率</h3><p>經過前面的計算得到了原始分數之後，我們需要將這段原始分數加入激勵函數來輸出機率。激勵函數有很多種，其中包括今天會介紹的Sigmoid以及softmax，之後會再介紹另外兩種。同樣地，如同先前所說，這些函數各有優缺點，我們在下面來一一討論：</p>
<h4 id="Sigmoid-function"><a href="#Sigmoid-function" class="headerlink" title="Sigmoid function"></a>Sigmoid function</h4><p><img src="https://i.imgur.com/28S02CU.png"><br><img src="https://i.imgur.com/2wk2nWj.png"><br>Sigmoid函數是最基礎，也是用來處理二元分類最常用的激勵函數。而Sigmoid activation function有幾個好處：</p>
<ol>
<li>Sigmoid可以將「原始分數」<strong>壓到[0, 1]之間</strong>，正好也是我們所需要的機率形式</li>
<li>在接近0以及接近1的地方，可以發現函數圖形逐漸趨平。這代表<strong>若有任何離群值（outlier），Sigmoid函數也可以把他壓縮到接近0或1，但卻又不會超過</strong>。</li>
<li><strong>可微分</strong>（differentiable），在後續做最佳解時會是一個有利的工具。</li>
</ol>
<h4 id="softmax-function"><a href="#softmax-function" class="headerlink" title="softmax function"></a>softmax function</h4><p>softmax跟Sigmoid不同的地方在於，這是做多元分類時常用的激勵函數，只是差別在於前者只會給一個機率，而softmax則是會給每個標籤相對應機率，然後加總起來都會等於1。<br><img src="https://i.imgur.com/K8zftXE.png"><br>所以假如說加入「原始分數」，就會是這樣的結果。<br><img src="https://i.imgur.com/2ly0KbI.png"></p>
<h3 id="最大化與正確答案相符的可能性"><a href="#最大化與正確答案相符的可能性" class="headerlink" title="最大化與正確答案相符的可能性"></a>最大化與正確答案相符的可能性</h3><p>前面你可能會發現，咦？那權重是怎麼來的？這就要先從Loss function開始講起：</p>
<h4 id="損失函數（loss-function）"><a href="#損失函數（loss-function）" class="headerlink" title="損失函數（loss function）"></a>損失函數（loss function）</h4><p>損失函數其實就是為了要評估<strong>實際答案跟預測答案之間的差距</strong>，而要找出這段差距，首先要先進行條件最大機率估算（conditional maximum likelihood estimation），聽起來很複雜，但其實就是要將<strong>預測正確的可能性最大化</strong>，也就是所謂的log-likelihood。而權重就會在每一次的計算過程中不斷調整，直到找到最佳解。在這邊不會有複雜的數學推演，我只會簡單介紹計算的邏輯。<br><img src="https://i.imgur.com/PJ2renE.png"><br>這裡是一個最大化的最佳解問題。那為了將它變成損失函數，也就是最小化的最佳解問題，在這裡會乘上一個負號<br><img src="https://i.imgur.com/1PnzQsf.png"></p>
<h4 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h4><p>那要解這個最小化問題，在這邊會使用的方法就是梯度下降（gradient descent）。</p>
<p>這名字聽起來好像很可怕，<del>用手算確實可怕，回想我大學在資管系修作業研究的辛酸血淚史（一抹淚）</del>，簡單來說，梯度下降法是一種找出最小化最佳解的一種演算法，意味著找出在函數空間中，斜率（slope）往上升程度最大的方向，並往這個方向的<strong>反方向</strong>前進。是不是不知道我在講什麼？我們馬上來看看一維簡化圖。</p>
<p><img src="https://i.imgur.com/kW3hAki.png"></p>
<p>首先我們可以先對 w1 微分（這就是為什麼可微分很重要），找出在w1這個點的切線斜率是正亦或是負。若是正（切線方向為<code>/</code>）則代表應該要往左前進。而圖中 w1 的斜率是負的（切線方向為<code>\</code>），所以方向則是往右，方能找到最佳最小值。</p>
<p>但實務上不可能會有這種只有一維的資料吧！所以事實上函數圖形長得會像這樣：<br><img src="https://i.imgur.com/tb6k3ox.png"></p>
<p>我自己是覺得很像螺仔餅啦，不覺得嗎？<del>我也是去查知道這餅乾的正式名稱</del></p>
<p><img src="https://cc.tvbs.com.tw/img/program/upload/2021/05/27/20210527131604-6951a668.jpg"><br>圖片來源：<a target="_blank" rel="noopener" href="https://woman.tvbs.com.tw/lifestyle/24209">TVBS</a></p>
<p>那因為 logistic regression 是一個凸函數（convex），而凸函數只會有一個最小值，所以 logistic regression 一定有解。但神經網路<em>不是凸函數（non-convex）</em>，所以在進行梯度下降時，就有可能困在同一個地方出不來，因此找不到最佳解。</p>
<h2 id="問題與討論"><a href="#問題與討論" class="headerlink" title="問題與討論"></a>問題與討論</h2><p>最後來比較看看貝氏分類模型跟羅吉斯回歸模型。首先，<strong>貝氏分類模型過度強調事件的獨立性，而這代表每個輸入的特徵都是獨立的。</strong> 這會有什麼問題？假如我們輸入了兩次一模一樣的特徵，貝氏分類會將其視為兩個 <strong>完全不同</strong> 的特徵，並將這些特徵彼此相乘，最後結果導致模型過度側重這個特徵。但相對的，羅吉斯回歸就不會有這個問題，因為權重會依照特徵進行調整，將權重分配到高度相關的特徵。</p>
<p>但這就代表貝氏分類一無是處嗎？倒也不然。貝氏分類在處理少量資料時，就可以有非常好的表現。且貝氏分類器簡單，訓練速度較快，因此貝氏分類器也是輸人不輸陣的喔！</p>
<p>這裡就再次回應先前所說，沒有什麼最好的方法，只有最適合的方法。最重要的，是了解需求後，找出最適合任務的處理方式，才是最重要的！</p>
<p>好，今天講到這裡，明天要進入深度學習的領域囉！</p>
<p>資料與圖片來源：<br><a target="_blank" rel="noopener" href="https://web.stanford.edu/~jurafsky/slp3/5.pdf">Speech and Language Processing</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一頁"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一頁"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa-solid fa-code"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yun Chuang (Milan)</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/hijiki.model.json"},"display":{"superSample":2,"width":250,"height":500,"position":"right","hOffset":-30,"vOffset":-130},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false});</script></body>
</html>
